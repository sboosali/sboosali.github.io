-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | enumerate all the values in a finite type (automatically)
--   
--   provides
--   
--   <ul>
--   <li>(1) a typeclass for enumerating all values in a finite type,</li>
--   <li>(2) a generic instance for automatic deriving, and</li>
--   <li>(3) helpers that reify functions (partial or total, monadic or
--   pure) into a Map.</li>
--   </ul>
--   
--   see the <a>Enumerable</a> module for extensive documentation.
@package enumerate
@version 0.2.1


module Enumerate.Extra
int2natural :: Int -> Natural

-- | the power set of a set of values.
--   
--   <pre>
--   &gt;&gt;&gt; (powerset2matrix . powerSet . Set.fromList) [1..3]
--   [[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]
--   </pre>
powerSet :: (Ord a) => Set a -> Set (Set a)

-- | <pre>
--   &gt;&gt;&gt; (powerset2matrix . dropEach . Set.fromList) [1..3]
--   [[1,2],[1,3],[2,3]]
--   </pre>
dropEach :: (Ord a) => Set a -> Set (Set a)

-- | convert a power set to an isomorphic matrix, sorting the entries.
--   
--   (for doctest)
powerset2matrix :: Set (Set a) -> [[a]]

-- | (for doctest)
printMappings :: (Show a) => [[a]] -> IO ()

-- | Left-to-right composition
(>>>) :: Category k cat => cat a b -> cat b c -> cat a c

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and ignore the results. For a version that doesn't
--   ignore the results see <a>traverse</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()


-- | the cardinality of a finite type, at the type-level.
module Enumerate.Cardinality

-- | a type is finite, i.e. has a bounded size.
--   
--   laws:
--   
--   <ul>
--   <li>consistent with
--   <a>Enumerate.Enumerable</a>:<ul><li><pre><tt>cardinality</tt> =
--   <a>reifyCardinality</a></pre></li></ul>i.e. the value-level (a
--   <a>Natural</a>) matches the type-level (a <a>Nat</a>)</li>
--   </ul>
--   
--   e.g.
--   
--   <pre>
--   &gt;&gt;&gt; reifyCardinality ([]::[Bool])
--   2
--   </pre>
class Finite a where type family Cardinality a :: Nat Cardinality a = GCardinality (Rep a)

-- | <pre>
--   0
--   </pre>

-- | <pre>
--   1
--   </pre>

-- | <pre>
--   2
--   </pre>

-- | <pre>
--   3
--   </pre>

-- | <pre>
--   2^8
--   </pre>

-- | <pre>
--   2^8
--   </pre>

-- | <pre>
--   2^16
--   </pre>

-- | <pre>
--   2^16
--   </pre>

-- | <pre>
--   1114112
--   </pre>

-- | <pre>
--   1 + a
--   </pre>

-- | <pre>
--   a + b
--   </pre>

-- | the cardinality is a product of cardinalities.

-- | <pre>
--   a*b
--   </pre>

-- | <pre>
--   a*b*c
--   </pre>

-- | <pre>
--   a*b*c*d
--   </pre>

-- | <pre>
--   a*b*c*d*e
--   </pre>

-- | <pre>
--   a*b*c*d*e*f
--   </pre>

-- | <pre>
--   a*b*c*d*e*f*g
--   </pre>

-- | <pre>
--   2^a
--   </pre>

-- | <pre>
--   b^a
--   </pre>

-- | <pre>
--   &gt;&gt;&gt; reifyCardinality ([]::[Bool])
--   2
--   </pre>
reifyCardinality :: (KnownNat (Cardinality a)) => proxy a -> Natural

-- | typechecks only when the constraint is satisifed.
--   
--   a constaint.
type CardinalityWithin n a = IsCardinalityWithin n a ~ True

-- | a predicate, inclusive.
--   
--   <pre>
--   &gt; type CardinalityWithinAMillion a = CardinalityWithin 1000000 a
--   &gt; :kind! CardinalityWithinAMillion Bool
--   True
--   &gt; :kind! CardinalityWithinAMillion Char
--   False
--   </pre>
type IsCardinalityWithin n a = Cardinality a <=? n
instance Enumerate.Cardinality.Finite Data.Void.Void
instance Enumerate.Cardinality.Finite ()
instance Enumerate.Cardinality.Finite GHC.Types.Bool
instance Enumerate.Cardinality.Finite GHC.Types.Ordering
instance Enumerate.Cardinality.Finite (Data.Proxy.Proxy a)
instance Enumerate.Cardinality.Finite GHC.Int.Int8
instance Enumerate.Cardinality.Finite GHC.Word.Word8
instance Enumerate.Cardinality.Finite GHC.Int.Int16
instance Enumerate.Cardinality.Finite GHC.Word.Word16
instance Enumerate.Cardinality.Finite GHC.Types.Char
instance Enumerate.Cardinality.Finite a => Enumerate.Cardinality.Finite (GHC.Base.Maybe a)
instance (Enumerate.Cardinality.Finite a, Enumerate.Cardinality.Finite b) => Enumerate.Cardinality.Finite (Data.Either.Either a b)
instance (Enumerate.Cardinality.Finite (f a), Enumerate.Cardinality.Finite (Data.Vinyl.Core.Rec f as)) => Enumerate.Cardinality.Finite (Data.Vinyl.Core.Rec f (a : as))
instance Enumerate.Cardinality.Finite (Data.Vinyl.Core.Rec f '[])
instance (Enumerate.Cardinality.Finite a, Enumerate.Cardinality.Finite b) => Enumerate.Cardinality.Finite (a, b)
instance (Enumerate.Cardinality.Finite a, Enumerate.Cardinality.Finite b, Enumerate.Cardinality.Finite c) => Enumerate.Cardinality.Finite (a, b, c)
instance (Enumerate.Cardinality.Finite a, Enumerate.Cardinality.Finite b, Enumerate.Cardinality.Finite c, Enumerate.Cardinality.Finite d) => Enumerate.Cardinality.Finite (a, b, c, d)
instance (Enumerate.Cardinality.Finite a, Enumerate.Cardinality.Finite b, Enumerate.Cardinality.Finite c, Enumerate.Cardinality.Finite d, Enumerate.Cardinality.Finite e) => Enumerate.Cardinality.Finite (a, b, c, d, e)
instance (Enumerate.Cardinality.Finite a, Enumerate.Cardinality.Finite b, Enumerate.Cardinality.Finite c, Enumerate.Cardinality.Finite d, Enumerate.Cardinality.Finite e, Enumerate.Cardinality.Finite f) => Enumerate.Cardinality.Finite (a, b, c, d, e, f)
instance (Enumerate.Cardinality.Finite a, Enumerate.Cardinality.Finite b, Enumerate.Cardinality.Finite c, Enumerate.Cardinality.Finite d, Enumerate.Cardinality.Finite e, Enumerate.Cardinality.Finite f, Enumerate.Cardinality.Finite g) => Enumerate.Cardinality.Finite (a, b, c, d, e, f, g)
instance Enumerate.Cardinality.Finite a => Enumerate.Cardinality.Finite (Data.Set.Base.Set a)
instance (Enumerate.Cardinality.Finite a, Enumerate.Cardinality.Finite b) => Enumerate.Cardinality.Finite (a -> b)


-- | enumerate all values in a finite type.
--   
--   e.g.
--   
--   <pre>
--   data A
--     = A0 Bool
--     | A1 (Either Bool) (Maybe Bool)
--     | A2 (Bool, Bool)
--     | A3 (Set Bool)
--     deriving (Show,Generic,Enumerable)
--   
--   &gt; enumerate
--   A0 False
--   A0 True
--   A1 ...
--   
--   &gt; cardinality ([]::[A])
--   </pre>
--   
--   see the <a>Enumerable</a> class for documentation.
--   
--   see <a>Enumerate.Example</a> for examples.
--   
--   can also help automatically derive <tt><a>QuickCheck</a></tt>
--   instances:
--   
--   <pre>
--   newtype ValidString = ValidString String
--    deriving (Show)
--   validStrings :: [String]
--   makeValidString :: String -&gt; Maybe ValidString
--   makeValidString s = if s <tt>member</tt> validStrings then Just (ValidString s) else Nothing
--   instance <a>Enumerable</a> ValidString where enumerated = ValidString &lt;$&gt; validStrings ... -- manually (since normal String's are infinite)
--   instance <a>Arbitrary</a> ValidString where arbitrary = elements <a>enumerated</a>
--   
--   data ValidName = ValidName ValidString ValidString | CoolValidName [ValidString]
--    deriving (Show,Generic)
--   instance <a>Enumerable</a> ValidName -- automatically
--   
--   instance Arbitrary ValidName where arbitrary = elements <a>enumerated</a>
--   </pre>
--   
--   Provides instances for all base types (whenever possible):
--   
--   <ul>
--   <li>under <tt>Data.</tt> / <tt>Control.</tt> / <tt>System.</tt> /
--   <tt>Text.</tt>, and even <tt>GHC.</tt></li>
--   <li>even non-<a>Enum</a>s</li>
--   <li>except when too large (like <a>Int</a>) (see
--   <a>Enumerate.Large</a>)</li>
--   </ul>
--   
--   background on <tt>Generics</tt>:
--   
--   <ul>
--   <li><a>GHC.Generics</a></li>
--   </ul>
--   
--   also provides instances for:
--   
--   <ul>
--   <li>sets</li>
--   <li>vinyl records</li>
--   </ul>
--   
--   related packages:
--   
--   <ul>
--   <li><a>enumerable</a>. no <tt>Generic</tt> instance.</li>
--   <li><a>universe</a> no <tt>Generic</tt> instance.</li>
--   <li><a>SafeEnum</a> only <tt>Enum</tt>s</li>
--   <li><a>emgm</a>. allows infinite lists (by convention). too
--   heavyweight.</li>
--   <li><a>testing-feat</a>. too heavyweight (testing framework).</li>
--   <li><a>smallcheck</a> too heavyweight (testing framework). Series
--   enumerates up to some depth and can enumerated infinitely-inhabited
--   types.</li>
--   <li><a>quickcheck</a> too heavyweight (testing framework, randomness
--   unnecessary).</li>
--   </ul>
module Enumerate.Types

-- | enumerate the set of all values in a (finitely enumerable) type.
--   enumerates depth first.
--   
--   generalizes <a>Enum</a>s to any finite/discrete type. an Enumerable is
--   either:
--   
--   <ul>
--   <li>an Enum</li>
--   <li>a product of Enumerables</li>
--   <li>a sum of Enumerables</li>
--   </ul>
--   
--   can be implemented automatically via its <a>Generic</a> instance.
--   
--   laws:
--   
--   <ul>
--   <li>finite:<ul><li><pre><a>cardinality</a> /= _|_</pre></li></ul></li>
--   <li>consistent:<ul><li><pre><a>cardinality</a> _ = <a>length</a>
--   <a>enumerated</a></pre></li></ul>so you can index the
--   <a>enumerated</a> with a nonnegative index below the
--   <a>cardinality</a>.</li>
--   <li>distinct:<ul><li><pre>(Eq a) =&gt; <tt>nub</tt> <a>enumerated</a>
--   == <a>enumerated</a></pre></li></ul></li>
--   <li>complete:<ul><li><pre>x `<tt>elem'</tt>
--   <a>enumerated</a></pre></li></ul></li>
--   <li>coincides with <tt>Bounded</tt>
--   <tt>Enum</tt>s:<ul><li><pre>(<a>Enum</a> a, <a>Bounded</a> a) =&gt;
--   <a>enumerated</a> ==
--   <a>boundedEnumerated</a></pre></li><li><pre>(<a>Enum</a> a) =&gt;
--   <a>enumerated</a> == <a>enumEnumerated</a></pre></li></ul></li>
--   </ul>
--   
--   (<tt>Bounded</tt> constraint elided for convenience, but relevant.)
--   
--   ("inputs" a type, outputs a list of values).
--   
--   Every type in <tt>base</tt> (that can be an instance) is an instance.
class Enumerable a where enumerated = to <$> genumerated cardinality _ = genericLength (enumerated :: [a])
enumerated :: Enumerable a => [a]
cardinality :: Enumerable a => proxy a -> Natural

-- | wrap any <tt>(Bounded a, Enum a)</tt> to be a <tt>Enumerable</tt> via
--   <a>boundedEnumerated</a>.
--   
--   (avoids <tt>OverlappingInstances</tt>).
newtype WrappedBoundedEnum a
WrappedBoundedEnum :: a -> WrappedBoundedEnum a
[unwrapBoundedEnum] :: WrappedBoundedEnum a -> a

-- | (phantom in <tt>a</tt>)

-- | <pre>
--   -- (<a>toInteger</a> prevents overflow)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 + toInteger (maxBound::Int8) - toInteger (minBound::Int8)
--   256
--   </pre>

-- | <pre>
--   &gt;&gt;&gt; 1 + toInteger (maxBound::Int16) - toInteger (minBound::Int16)
--   65536
--   </pre>

-- | there are only a million (1,114,112) characters.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char (ord,chr)  -- 'ord', 'chr'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ord minBound
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ord maxBound
--   1114111
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length [chr 0 ..]
--   1114112
--   </pre>

-- | the sum type.
--   
--   the <a>cardinality</a> is the sum of the cardinalities of <tt>a</tt>
--   and <tt>b</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; cardinality ([] :: [Either Bool Ordering])
--   5
--   </pre>

-- | the product type.
--   
--   the <a>cardinality</a> is the product of the cardinalities of
--   <tt>a</tt> and <tt>b</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; cardinality ([] :: [(Bool,Ordering)])
--   6
--   </pre>

-- | 3

-- | 4

-- | 5

-- | 6

-- | 7

-- | the <a>cardinality</a> is the cardinality of the <a>powerSet</a> of
--   <tt>a</tt>, i.e. <tt>2^|a|</tt>. warning: it grows quickly. don't try
--   to take the power set of <a>Char</a>! or even <a>Word8</a>.
--   
--   the <a>cardinality</a> call is efficient (depending on the efficiency
--   of the base type's call). you should be able to safely call
--   <a>enumerateBelow</a>, unless the arithmetic itself becomes too large.
--   
--   <pre>
--   &gt;&gt;&gt; enumerated :: [Set Bool]
--   [fromList [],fromList [False],fromList [False,True],fromList [True]]
--   </pre>

-- | (<tt>a</tt> can be any <tt>Enumerable</tt>, unlike the <tt>Enum</tt>
--   instance where <tt>a</tt> is an <tt>Integral</tt>).

-- | the cardinality is a product of cardinalities.

-- | "Generic Enumerable", lifted to unary type constructors.
class GEnumerable f
genumerated :: GEnumerable f => [f x]
gcardinality :: GEnumerable f => proxy f -> Natural

-- | empty list

-- | singleton list

-- | call <a>enumerated</a>

-- | multiply lists with <tt>concatMap</tt>

-- | add lists with <tt>(&lt;&gt;)</tt>

-- | ignore selector metadata

-- | ignore constructor metadata

-- | ignore datatype metadata

-- | for non-<a>Generic</a> Bounded Enums:
--   
--   <pre>
--   instance Enumerable _ where
--    <a>enumerated</a> = boundedEnumerated
--    <a>cardinality</a> = <a>boundedCardinality</a>
--   </pre>
boundedEnumerated :: (Bounded a, Enum a) => [a]

-- | for non-<a>Generic</a> Bounded Enums.
--   
--   Assuming <a>Bounded</a> is correct, safely stop the enumeration (and
--   know where to start).
--   
--   behavior may be undefined when the cardinality of <tt>a</tt> is larger
--   than the cardinality of <tt>Int</tt>. this should be okay, as
--   <tt>Int</tt> is at least as big as <tt>Int64</tt>, which is at least
--   as big as all the monomorphic types in <tt>base</tt> that instantiate
--   <tt>Bounded</tt>. you can double-check with:
--   
--   <pre>
--   &gt;&gt;&gt; boundedCardinality (const(undefined::Int))   -- platform specific
--   18446744073709551616
--   </pre>
--   
--   <pre>
--   -- i.e. 1 + 9223372036854775807 - (-9223372036854775808)
--   </pre>
--   
--   works with non-zero-based Enum instances, like <tt>Int64</tt> or a
--   custom <tt>toEnum/fromEnum</tt>. assumes the enumeration's numbering
--   is contiguous, e.g. if <tt>fromEnum 0</tt> and <tt>fromEnum 2</tt>
--   both exist, then <tt>fromEnum 1</tt> should exist too.
boundedCardinality :: (Bounded a, Enum a) => proxy a -> Natural

-- | for non-<a>Generic</a> Enums:
--   
--   <pre>
--   instance Enumerable ... where
--    <a>enumerated</a> = enumEnumerated
--   </pre>
--   
--   the enum should still be bounded.
enumEnumerated :: (Enum a) => [a]

-- | for non-<a>Generic</a> Bounded Indexed (<a>Ix</a>) types:
--   
--   <pre>
--   instance Enumerable _ where
--    <a>enumerated</a> = indexedEnumerated
--    <a>cardinality</a> = <a>indexedCardinality</a>
--   </pre>
indexedEnumerated :: (Bounded a, Ix a) => [a]

-- | for non-<a>Generic</a> Bounded Indexed (<a>Ix</a>) types.
indexedCardinality :: (Bounded a, Ix a) => proxy a -> Natural

-- | enumerate only when the cardinality is small enough. returns the
--   cardinality when too large.
--   
--   <pre>
--   &gt;&gt;&gt; enumerateBelow 2 :: Either Natural [Bool]
--   Left 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; enumerateBelow 100 :: Either Natural [Bool]
--   Right [False,True]
--   </pre>
--   
--   useful when you've established that traversing a list below some
--   length and consuming its values is reasonable for your application.
--   e.g. after benchmarking, you think you can process a billion entries
--   within a minute.
enumerateBelow :: (Enumerable a) => Natural -> Either Natural [a]

-- | enumerate only when completely evaluating the list doesn't timeout
--   (before the given number of microseconds).
--   
--   <pre>
--   &gt;&gt;&gt; enumerateTimeout (2 * 10^6) :: IO (Maybe [Bool])  -- two seconds
--   Just [False,True]
--   </pre>
enumerateTimeout :: (Enumerable a, NFData a) => Int -> IO (Maybe [a])
instance Enumerate.Types.Enumerable Data.Void.Void
instance Enumerate.Types.Enumerable ()
instance Enumerate.Types.Enumerable GHC.Types.Bool
instance Enumerate.Types.Enumerable GHC.Types.Ordering
instance Enumerate.Types.Enumerable (Data.Proxy.Proxy a)
instance Enumerate.Types.Enumerable a => Enumerate.Types.Enumerable (Data.Functor.Identity.Identity a)
instance Enumerate.Types.Enumerable a => Enumerate.Types.Enumerable (Control.Applicative.Const a b)
instance (a ~ b) => Enumerate.Types.Enumerable (a Data.Type.Equality.:~: b)
instance GHC.Types.Coercible a b => Enumerate.Types.Enumerable (Data.Type.Coercion.Coercion a b)
instance Enumerate.Types.Enumerable GHC.Int.Int8
instance Enumerate.Types.Enumerable GHC.Word.Word8
instance Enumerate.Types.Enumerable GHC.Int.Int16
instance Enumerate.Types.Enumerable GHC.Word.Word16
instance Enumerate.Types.Enumerable GHC.Types.Char
instance (Enumerate.Types.Enumerable a, Enumerate.Types.Enumerable b) => Enumerate.Types.Enumerable (Data.Either.Either a b)
instance Enumerate.Types.Enumerable a => Enumerate.Types.Enumerable (GHC.Base.Maybe a)
instance (Enumerate.Types.Enumerable a, Enumerate.Types.Enumerable b) => Enumerate.Types.Enumerable (a, b)
instance (Enumerate.Types.Enumerable a, Enumerate.Types.Enumerable b, Enumerate.Types.Enumerable c) => Enumerate.Types.Enumerable (a, b, c)
instance (Enumerate.Types.Enumerable a, Enumerate.Types.Enumerable b, Enumerate.Types.Enumerable c, Enumerate.Types.Enumerable d) => Enumerate.Types.Enumerable (a, b, c, d)
instance (Enumerate.Types.Enumerable a, Enumerate.Types.Enumerable b, Enumerate.Types.Enumerable c, Enumerate.Types.Enumerable d, Enumerate.Types.Enumerable e) => Enumerate.Types.Enumerable (a, b, c, d, e)
instance (Enumerate.Types.Enumerable a, Enumerate.Types.Enumerable b, Enumerate.Types.Enumerable c, Enumerate.Types.Enumerable d, Enumerate.Types.Enumerable e, Enumerate.Types.Enumerable f) => Enumerate.Types.Enumerable (a, b, c, d, e, f)
instance (Enumerate.Types.Enumerable a, Enumerate.Types.Enumerable b, Enumerate.Types.Enumerable c, Enumerate.Types.Enumerable d, Enumerate.Types.Enumerable e, Enumerate.Types.Enumerable f, Enumerate.Types.Enumerable g) => Enumerate.Types.Enumerable (a, b, c, d, e, f, g)
instance (Enumerate.Types.Enumerable a, GHC.Classes.Ord a) => Enumerate.Types.Enumerable (Data.Set.Base.Set a)
instance Enumerate.Types.Enumerable Data.Char.GeneralCategory
instance Enumerate.Types.Enumerable GHC.IO.IOMode.IOMode
instance Enumerate.Types.Enumerable GHC.IO.Device.SeekMode
instance Enumerate.Types.Enumerable GHC.Exception.ArithException
instance Enumerate.Types.Enumerable GHC.IO.Exception.AsyncException
instance Enumerate.Types.Enumerable Control.Exception.Base.NonTermination
instance Enumerate.Types.Enumerable Control.Exception.Base.NestedAtomically
instance Enumerate.Types.Enumerable GHC.IO.Exception.BlockedIndefinitelyOnMVar
instance Enumerate.Types.Enumerable GHC.IO.Exception.BlockedIndefinitelyOnSTM
instance Enumerate.Types.Enumerable GHC.IO.Exception.AllocationLimitExceeded
instance Enumerate.Types.Enumerable GHC.IO.Exception.Deadlock
instance Enumerate.Types.Enumerable GHC.IO.Handle.Types.Newline
instance Enumerate.Types.Enumerable GHC.IO.Handle.Types.NewlineMode
instance Enumerate.Types.Enumerable Text.Printf.FormatAdjustment
instance Enumerate.Types.Enumerable Text.Printf.FormatSign
instance Enumerate.Types.Enumerable Data.Monoid.All
instance Enumerate.Types.Enumerable Data.Monoid.Any
instance Enumerate.Types.Enumerable a => Enumerate.Types.Enumerable (Data.Monoid.Dual a)
instance Enumerate.Types.Enumerable a => Enumerate.Types.Enumerable (Data.Monoid.First a)
instance Enumerate.Types.Enumerable a => Enumerate.Types.Enumerable (Data.Monoid.Last a)
instance Enumerate.Types.Enumerable a => Enumerate.Types.Enumerable (Data.Monoid.Sum a)
instance Enumerate.Types.Enumerable a => Enumerate.Types.Enumerable (Data.Monoid.Product a)
instance Enumerate.Types.Enumerable (a -> a) => Enumerate.Types.Enumerable (Data.Monoid.Endo a)
instance Enumerate.Types.Enumerable (f a) => Enumerate.Types.Enumerable (Data.Monoid.Alt f a)
instance Enumerate.Types.Enumerable a => Enumerate.Types.Enumerable (Data.Complex.Complex a)
instance Enumerate.Types.Enumerable a => Enumerate.Types.Enumerable (Data.Ord.Down a)
instance Enumerate.Types.Enumerable System.Posix.Types.CIno
instance Enumerate.Types.Enumerable System.Posix.Types.CMode
instance Enumerate.Types.Enumerable Foreign.C.Types.CChar
instance Enumerate.Types.Enumerable Foreign.C.Types.CWchar
instance Enumerate.Types.Enumerable Foreign.C.Types.CSChar
instance Enumerate.Types.Enumerable Foreign.C.Types.CUChar
instance Enumerate.Types.Enumerable Foreign.C.Types.CShort
instance Enumerate.Types.Enumerable Foreign.C.Types.CUShort
instance Enumerate.Types.Enumerable GHC.Generics.Associativity
instance Enumerate.Types.Enumerable GHC.Exts.SpecConstrAnnotation
instance Enumerate.Types.Enumerable GHC.IO.Buffer.BufferState
instance Enumerate.Types.Enumerable GHC.IO.Device.IODeviceType
instance Enumerate.Types.Enumerable GHC.IO.Encoding.Failure.CodingFailureMode
instance Enumerate.Types.Enumerable GHC.IO.Encoding.Types.CodingProgress
instance Enumerate.Types.Enumerable GHC.RTS.Flags.DoTrace
instance Enumerate.Types.Enumerable GHC.RTS.Flags.DoHeapProfile
instance Enumerate.Types.Enumerable GHC.RTS.Flags.DoCostCentres
instance Enumerate.Types.Enumerable GHC.RTS.Flags.GiveGCStats
instance (GHC.Enum.Bounded a, GHC.Enum.Enum a) => Enumerate.Types.Enumerable (Enumerate.Types.WrappedBoundedEnum a)
instance (Enumerate.Types.Enumerable (f a), Enumerate.Types.Enumerable (Data.Vinyl.Core.Rec f as)) => Enumerate.Types.Enumerable (Data.Vinyl.Core.Rec f (a : as))
instance Enumerate.Types.Enumerable (Data.Vinyl.Core.Rec f '[])
instance Enumerate.Types.GEnumerable GHC.Generics.V1
instance Enumerate.Types.GEnumerable GHC.Generics.U1
instance Enumerate.Types.Enumerable a => Enumerate.Types.GEnumerable (GHC.Generics.K1 GHC.Generics.R a)
instance (Enumerate.Types.GEnumerable f, Enumerate.Types.GEnumerable g) => Enumerate.Types.GEnumerable (f GHC.Generics.:*: g)
instance (Enumerate.Types.GEnumerable f, Enumerate.Types.GEnumerable g) => Enumerate.Types.GEnumerable (f GHC.Generics.:+: g)
instance Enumerate.Types.GEnumerable f => Enumerate.Types.GEnumerable (GHC.Generics.M1 GHC.Generics.S t f)
instance Enumerate.Types.GEnumerable f => Enumerate.Types.GEnumerable (GHC.Generics.M1 GHC.Generics.C t f)
instance Enumerate.Types.GEnumerable f => Enumerate.Types.GEnumerable (GHC.Generics.M1 GHC.Generics.D t f)


-- | usage:
--   
--   <pre>
--   data A = ...
--   
--   instance <a>Bounded</a> A where
--    minBound = <a>minBound_enumerable</a> array_A
--    maxBound = <a>maxBound_enumerable</a> array_A
--   
--   instance <a>Enum</a> A where
--    toEnum   = <a>toEnum_enumerable</a>   array_A
--    fromEnum = <a>fromEnum_enumerable</a> table_A
--   
--   -- CAF
--   array_A :: <a>Array</a> Int A
--   array_A = <a>array_enumerable</a>
--   
--   -- CAF
--   table_A :: <a>Map</a> A Int
--   table_A = <a>table_enumerable</a>
--   
--   -- we must pass in <a>CAF</a>s
--   -- (i.e. expressions that are top-level and unconstrained),
--   -- which will be shared between all calls to minBound<i>maxBound</i>toEnum/fromEnum.
--   -- TODO must we?
--   </pre>
--   
--   <ul>
--   <li>-TODO template-haskell</li>
--   </ul>
--   
--   (also see the source of <a>Enumerate.Example</a>)
module Enumerate.Enum
minBound_enumerable :: (Enumerable a) => Array Int a -> a
maxBound_enumerable :: (Enumerable a) => Array Int a -> a
toEnum_enumerable :: (Enumerable a) => Array Int a -> (Int -> a)
fromEnum_enumerable :: (Enumerable a, Ord a) => Map a Int -> (a -> Int)
array_enumerable :: (Enumerable a) => Array Int a
table_enumerable :: (Enumerable a, Ord a) => Map a Int


-- | orphan instances, of <a>Enumerable</a>, for large types (i.e.
--   <a>Word32</a> / <a>Word64</a> / <a>Int32</a> / <a>Int64</a>).
--   
--   see:
--   
--   <ul>
--   <li><a>boundedEnumerated</a>, <a>boundedCardinality</a></li>
--   </ul>
--   
--   (that are included for completeness, but not exported by default (i.e.
--   by <a>Enumerate</a>). you probably want build-time instance-resolution
--   errors instead of probable runtime non-termination).
module Enumerate.Orphans.Large

-- | finite but too large. <tt>2^64</tt> is a few billion.
--   
--   <pre>
--   &gt;&gt;&gt; 1 + toInteger (maxBound::Int32) - toInteger (minBound::Int32)
--   4294967296
--   </pre>

-- | finite but too large. <tt>2^64</tt> is over a billion billion.
--   
--   e.g. <a>reifyFunction</a> (which takes time linear in the domain) on a
--   function of type <tt>(:: Int -&gt; Bool)</tt>, won't terminate anytime
--   soon.
--   
--   <pre>
--   &gt;&gt;&gt; 1 + toInteger (maxBound::Int64) - toInteger (minBound::Int64)
--   18446744000000000000
--   </pre>

-- | finite but too large.
--   
--   <pre>
--   &gt;&gt;&gt; 1 + toInteger (maxBound::Int) - toInteger (minBound::Int)
--   ...
--   </pre>
instance Enumerate.Types.Enumerable GHC.Int.Int32
instance Enumerate.Types.Enumerable GHC.Word.Word32
instance Enumerate.Types.Enumerable GHC.Int.Int64
instance Enumerate.Types.Enumerable GHC.Word.Word64
instance Enumerate.Types.Enumerable GHC.Types.Int
instance Enumerate.Types.Enumerable GHC.Types.Word


-- | enumerate all values in a finite type.
--   
--   e.g.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric
--   
--   &gt;&gt;&gt; :set -XDeriveAnyClass
--   </pre>
--   
--   given:
--   
--   <pre>
--   -- an <a>Enumerable</a> can be automatically derived,
--   -- even though it's a nested sum type (and thus not an <tt>Enum</tt>).
--   data Edit = Edit Action Slice Region
--    deriving (Show,Read,Eq,Ord,Generic,Enumerable)
--   
--   data Action
--    = Select
--    | Copy
--    | Delete
--    deriving (Show,Read,Eq,Ord,Enum,Bounded,Generic,Enumerable)
--   
--   data Slice
--    = Whole
--    | Backwards
--    | Forwards
--    deriving (Show,Read,Eq,Ord,Enum,Bounded,Generic,Enumerable)
--   
--   data Region
--    = Character
--    | Token
--    | Line
--    deriving (Show,Read,Eq,Ord,Enum,Bounded,Generic,Enumerable)
--   </pre>
--   
--   we can enumerate every possible editing action:
--   
--   <pre>
--   &gt; <a>enumerated</a> :: [Edit]
--   Edit Select Whole Character
--   Edit Select Whole Token
--   Edit Select Whole Line
--   Edit Select Backwards Character
--   Edit Select Backwards Token
--   Edit Select Backwards Line
--   Edit Select Forwards Character
--   Edit Select Forwards Token
--   Edit Select Forwards Line
--   Edit Copy Whole Character
--   Edit Copy Whole Token
--   Edit Copy Whole Line
--   Edit Copy Backwards Character
--   Edit Copy Backwards Token
--   Edit Copy Backwards Line
--   Edit Copy Forwards Character
--   Edit Copy Forwards Token
--   Edit Copy Forwards Line
--   Edit Delete Whole Character
--   Edit Delete Whole Token
--   Edit Delete Whole Line
--   Edit Delete Backwards Character
--   Edit Delete Backwards Token
--   Edit Delete Backwards Line
--   Edit Delete Forwards Character
--   Edit Delete Forwards Token
--   Edit Delete Forwards Line
--   </pre>
--   
--   see <a>Enumerate.Types</a> for detailed documentation.
--   
--   the modules <a>Enumerate.Large</a> and <a>Enumerate.Function</a> have
--   orphan instances for large types, and aren't reexported by default.
--   this makes attempting to enumerate them a type error, rather than
--   runtime non-termination.
--   
--   See the source of <a>Enumerate.Example</a> for an example.
module Enumerate

module Enumerate.Main
main :: IO ()


-- | ## Bounded Enum instance
--   
--   You can (semi-)automatically derive efficient 'Bounded'/'Enum'
--   instances:
--   
--   <pre>
--   instance Bounded (Demo Bool) where
--    minBound = <a>minBound_enumerable</a> array_DemoBool
--    maxBound = <a>maxBound_enumerable</a> array_DemoBool
--   
--   instance Enum (Demo Bool) where
--    toEnum   = <a>toEnum_enumerable</a>   array_DemoBool
--    fromEnum = <a>fromEnum_enumerable</a> table_DemoBool
--   
--   -- CAF
--   array_DemoBool :: <a>Array</a> Int (Demo Bool)
--   array_DemoBool = <a>array_enumerable</a>
--   
--   -- CAF
--   table_DemoBool :: <a>Map</a> (Demo Bool) Int
--   table_DemoBool = <a>table_enumerable</a>
--   </pre>
--   
--   ## Run
--   
--   <pre>
--   stack build &amp;&amp; stack exec -- enumerable-example
--   </pre>
--   
--   outputs:
--   
--   <pre>
--   -- A Void
--   &gt;&gt;&gt; cardinality ([]::[A Void])
--   1
--   &gt;&gt;&gt; enumerated :: [A Void]
--   A3 (fromList [])
--   
--   
--   -- A ()
--   &gt;&gt;&gt; cardinality ([]::[A ()])
--   8
--   &gt;&gt;&gt; enumerated :: [A ()]
--   A0 ()
--   A1 Nothing (Left ())
--   A1 Nothing (Right ())
--   A1 (Just ()) (Left ())
--   A1 (Just ()) (Right ())
--   A2 ((),())
--   A3 (fromList [])
--   A3 (fromList [()])
--   
--   
--   -- A Bool
--   &gt;&gt;&gt; cardinality ([]::[A Bool])
--   22
--   &gt;&gt;&gt; enumerated :: [A Bool]
--   A0 False
--   A0 True
--   A1 Nothing (Left False)
--   A1 Nothing (Left True)
--   A1 Nothing (Right False)
--   A1 Nothing (Right True)
--   A1 (Just False) (Left False)
--   A1 (Just False) (Left True)
--   A1 (Just False) (Right False)
--   A1 (Just False) (Right True)
--   A1 (Just True) (Left False)
--   A1 (Just True) (Left True)
--   A1 (Just True) (Right False)
--   A1 (Just True) (Right True)
--   A2 (False,False)
--   A2 (False,True)
--   A2 (True,False)
--   A2 (True,True)
--   A3 (fromList [])
--   A3 (fromList [False])
--   A3 (fromList [False,True])
--   A3 (fromList [True])
--   
--   
--   -- A Ordering
--   &gt;&gt;&gt; cardinality ([]::[A Ordering])
--   44
--   &gt;&gt;&gt; enumerated :: [A Ordering]
--   A0 LT
--   A0 EQ
--   A0 GT
--   A1 Nothing (Left LT)
--   A1 Nothing (Left EQ)
--   A1 Nothing (Left GT)
--   A1 Nothing (Right LT)
--   A1 Nothing (Right EQ)
--   A1 Nothing (Right GT)
--   A1 (Just LT) (Left LT)
--   A1 (Just LT) (Left EQ)
--   A1 (Just LT) (Left GT)
--   A1 (Just LT) (Right LT)
--   A1 (Just LT) (Right EQ)
--   A1 (Just LT) (Right GT)
--   A1 (Just EQ) (Left LT)
--   A1 (Just EQ) (Left EQ)
--   A1 (Just EQ) (Left GT)
--   A1 (Just EQ) (Right LT)
--   A1 (Just EQ) (Right EQ)
--   A1 (Just EQ) (Right GT)
--   A1 (Just GT) (Left LT)
--   A1 (Just GT) (Left EQ)
--   A1 (Just GT) (Left GT)
--   A1 (Just GT) (Right LT)
--   A1 (Just GT) (Right EQ)
--   A1 (Just GT) (Right GT)
--   A2 (LT,LT)
--   A2 (LT,EQ)
--   A2 (LT,GT)
--   A2 (EQ,LT)
--   A2 (EQ,EQ)
--   A2 (EQ,GT)
--   A2 (GT,LT)
--   A2 (GT,EQ)
--   A2 (GT,GT)
--   A3 (fromList [])
--   A3 (fromList [LT])
--   A3 (fromList [LT,EQ])
--   A3 (fromList [LT,EQ,GT])
--   A3 (fromList [LT,GT])
--   A3 (fromList [EQ])
--   A3 (fromList [EQ,GT])
--   A3 (fromList [GT])
--   </pre>
module Enumerate.Example
main :: IO [()]

-- | (for documentation)
--   
--   demonstrates: empty type, unit type, product type, sum type, type
--   variable.
--   
--   with <tt>{-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}</tt>, the
--   derivation is a one-liner:
--   
--   <pre>
--   data Demo a = ... deriving (Show,Generic,Enumerable)
--   </pre>
data Demo a
Demo0 :: Void -> Demo a
Demo1 :: Demo a
Demo2 :: Bool -> (Maybe Bool) -> Demo a
Demo3 :: a -> Demo a
data A a
A0 :: a -> A a
A1 :: (Maybe a) -> (Either a a) -> A a
A2 :: (a, a) -> A a
A3 :: (Set a) -> A a

-- | (for documentation)
--   
--   <pre>
--   demoEnumerated = enumerated
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse_ print demoEnumerated
--   Demo1
--   Demo2 False Nothing
--   Demo2 False (Just False)
--   Demo2 False (Just True)
--   Demo2 True Nothing
--   Demo2 True (Just False)
--   Demo2 True (Just True)
--   Demo3 False
--   Demo3 True
--   </pre>
demoEnumerated :: [Demo Bool]
array_DemoBool :: Array Int (Demo Bool)
table_DemoBool :: Map (Demo Bool) Int
instance GHC.Generics.Constructor Enumerate.Example.C1_3A
instance GHC.Generics.Constructor Enumerate.Example.C1_2A
instance GHC.Generics.Constructor Enumerate.Example.C1_1A
instance GHC.Generics.Constructor Enumerate.Example.C1_0A
instance GHC.Generics.Datatype Enumerate.Example.D1A
instance GHC.Generics.Constructor Enumerate.Example.C1_3Demo
instance GHC.Generics.Constructor Enumerate.Example.C1_2Demo
instance GHC.Generics.Constructor Enumerate.Example.C1_1Demo
instance GHC.Generics.Constructor Enumerate.Example.C1_0Demo
instance GHC.Generics.Datatype Enumerate.Example.D1Demo
instance (GHC.Classes.Ord a, Enumerate.Types.Enumerable a) => Enumerate.Types.Enumerable (Enumerate.Example.A a)
instance GHC.Generics.Generic (Enumerate.Example.A a)
instance GHC.Show.Show a => GHC.Show.Show (Enumerate.Example.A a)
instance Enumerate.Types.Enumerable a => Enumerate.Types.Enumerable (Enumerate.Example.Demo a)
instance GHC.Generics.Generic (Enumerate.Example.Demo a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Enumerate.Example.Demo a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Enumerate.Example.Demo a)
instance GHC.Show.Show a => GHC.Show.Show (Enumerate.Example.Demo a)
instance GHC.Enum.Bounded (Enumerate.Example.Demo GHC.Types.Bool)
instance GHC.Enum.Enum (Enumerate.Example.Demo GHC.Types.Bool)
