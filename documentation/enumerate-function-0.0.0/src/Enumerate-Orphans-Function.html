<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>sources/Enumerate/Orphans/Function.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE TypeFamilies, ExplicitNamespaces, DataKinds, UndecidableInstances #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# OPTIONS_GHC -fno-warn-orphans #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-| orphan instances, of 'Enumerate'\/'Eq'\/'Show', for functions:
<a name="line-4"></a>
<a name="line-5"></a>* @instance (Enumerable a, Enumerable b, Ord a,  Ord b)  =&gt; Enumerable (a -&gt; b)@
<a name="line-6"></a>* @instance (Enumerable a,               Eq b)           =&gt; Eq         (a -&gt; b)@
<a name="line-7"></a>* @instance (Enumerable a,               Show a, Show b) =&gt; Show       (a -&gt; b)@
<a name="line-8"></a>
<a name="line-9"></a>see:
<a name="line-10"></a>
<a name="line-11"></a>* 'functionEnumerated', 'functionCardinality'
<a name="line-12"></a>* 'extensionallyEqual', 'extensionallyUnequal'
<a name="line-13"></a>* 'functionShowsPrec'
<a name="line-14"></a>
<a name="line-15"></a>(that are included for completeness, but not exported by default
<a name="line-16"></a>(i.e. by "Enumerate").
<a name="line-17"></a>you probably want build-time instance-resolution errors,
<a name="line-18"></a>rather than possible runtime non-termination).
<a name="line-19"></a>
<a name="line-20"></a>
<a name="line-21"></a>@-- doctest@
<a name="line-22"></a>
<a name="line-23"></a>&gt;&gt;&gt; :set -XLambdaCase
<a name="line-24"></a>
<a name="line-25"></a>-}</span>
<a name="line-26"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Enumerate</span><span class='hs-varop'>.</span><span class='hs-conid'>Orphans</span><span class='hs-varop'>.</span><span class='hs-conid'>Function</span> <span class='hs-keyword'>where</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Enumerate</span><span class='hs-varop'>.</span><span class='hs-conid'>Types</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Enumerate</span><span class='hs-varop'>.</span><span class='hs-conid'>Function</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span>
<a name="line-29"></a>
<a name="line-30"></a>
<a name="line-31"></a><a name="instance%20Enumerable%20(a%20-%3e%20b)"></a><span class='hs-comment'>{-| the exponential type.
<a name="line-32"></a>
<a name="line-33"></a>the 'cardinality' is the cardinality of @b@ raised to the cardinality @a@, i.e. @|b|^|a|@.
<a name="line-34"></a>
<a name="line-35"></a>warning: it grows very quickly.
<a name="line-36"></a>
<a name="line-37"></a>might be useful for generating random functions on small types,
<a name="line-38"></a>like to fuzz test type class laws.
<a name="line-39"></a>
<a name="line-40"></a>the 'cardinality' call is efficient (depending on the efficiency of the base type's call).
<a name="line-41"></a>you should be able to safely (WRT performance) call 'enumerateBelow',
<a name="line-42"></a>unless the arithmetic itself becomes too expensive.
<a name="line-43"></a>
<a name="line-44"></a>@
<a name="line-45"></a>instance ('Enumerable' a, Enumerable b, 'Ord' a, Ord b) =&gt; Enumerable (a -&gt; b) where
<a name="line-46"></a> enumerated = 'functionEnumerated'
<a name="line-47"></a>@
<a name="line-48"></a>
<a name="line-49"></a>-}</span>
<a name="line-50"></a><a name="instance%20Enumerable%20(a%20-%3e%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Enumerable</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Enumerable</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Enumerable</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span> <span class='hs-comment'>--TODO, no (oprhan) instance, just the standalone function/type-instance?</span>
<a name="line-51"></a> <span class='hs-comment'>-- -- type Cardinality (a -&gt; b) = (Cardinality b) ^ (Cardinality a)</span>
<a name="line-52"></a> <span class='hs-varid'>enumerated</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>functionEnumerated</span>
<a name="line-53"></a> <span class='hs-varid'>cardinality</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>functionCardinality</span>
<a name="line-54"></a>
<a name="line-55"></a><a name="instance%20Eq%20(a%20-%3e%20b)"></a><span class='hs-comment'>{-| brute-force function extensionality.
<a name="line-56"></a>
<a name="line-57"></a>warning: the size of the domain grows exponentially in the number of arguments.
<a name="line-58"></a>
<a name="line-59"></a>&gt;&gt;&gt; (\case LT -&gt; False; EQ -&gt; False; GT -&gt; False) == const False
<a name="line-60"></a>True
<a name="line-61"></a>&gt;&gt;&gt; (\case LT -&gt; False; EQ -&gt; False; GT -&gt; False) == const True
<a name="line-62"></a>False
<a name="line-63"></a>
<a name="line-64"></a>because functions are curried, the instance is recursive,
<a name="line-65"></a>and it works on functions of any arity:
<a name="line-66"></a>
<a name="line-67"></a>&gt; -- De Morgan's laws
<a name="line-68"></a>&gt;&gt;&gt; (\x y -&gt; not (x &amp;&amp; y)) == (\x y -&gt; not x || not y)
<a name="line-69"></a>True
<a name="line-70"></a>&gt;&gt;&gt; (\x y -&gt; not (x || y)) == (\x y -&gt; not x &amp;&amp; not y)
<a name="line-71"></a>True
<a name="line-72"></a>
<a name="line-73"></a>-}</span>
<a name="line-74"></a><a name="instance%20Eq%20(a%20-%3e%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Enumerable</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Eq</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-75"></a> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extensionallyEqual</span>
<a name="line-76"></a> <span class='hs-layout'>(</span><span class='hs-varop'>/=</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extensionallyUnequal</span>
<a name="line-77"></a>
<a name="line-78"></a><a name="instance%20Show%20(a%20-%3e%20b)"></a><span class='hs-comment'>{-|
<a name="line-79"></a>
<a name="line-80"></a>-- &gt;&gt;&gt; not
<a name="line-81"></a>-- unsafeFromList [(False,True),(True,False)]
<a name="line-82"></a>
<a name="line-83"></a>because functions are curried, the instance is recursive,
<a name="line-84"></a>and it works on functions of any arity:
<a name="line-85"></a>
<a name="line-86"></a>-- &gt;&gt;&gt; (&amp;&amp;)
<a name="line-87"></a>-- unsafeFromList [(False,unsafeFromList [(False,False),(True,False)]),(True,unsafeFromList [(False,False),(True,True)])]
<a name="line-88"></a>
<a name="line-89"></a>-}</span>
<a name="line-90"></a><a name="instance%20Show%20(a%20-%3e%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Enumerable</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Show</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-91"></a> <span class='hs-varid'>showsPrec</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>functionShowsPrec</span>
</pre></body>
</html>
