-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | TODO
--   
--   TODO
@package enumerate-function
@version 0.0.0

module Enumerate.Function.Extra
nothing :: (Monad m) => m ()
maybe2bool :: Maybe a -> Bool
either2maybe :: Either e a -> Maybe a
either2bool :: Either e a -> Bool

-- | <pre>
--   failed = <a>throwM</a> . <a>userError</a>
--   </pre>
failed :: (MonadThrow m) => String -> m a

-- | generalize a function that fails with <tt>Nothing</tt>.
maybe2throw :: (a -> Maybe b) -> (forall m. MonadThrow m => a -> m b)

-- | generalize a function that fails with <tt>[]</tt>.
list2throw :: (a -> [b]) -> (forall m. MonadThrow m => a -> m b)

-- | generalize a function that fails with <tt>Left</tt>.
either2throw :: (a -> Either SomeException b) -> (forall m. MonadThrow m => a -> m b)

-- | specialization
throw2maybe :: (forall m. MonadThrow m => a -> m b) -> (a -> Maybe b)

-- | specialization
throw2either :: (forall m. MonadThrow m => a -> m b) -> (a -> Either SomeException b)

-- | specialization
throw2list :: (forall m. MonadThrow m => a -> m b) -> (a -> [b])

-- | makes an *unsafely*-partial function (i.e. a function that throws
--   exceptions or that has inexhaustive pattern matching) into a
--   *safely*-partial function (i.e. that explicitly returns in a monad
--   that supports failure).
totalizeFunction :: (NFData b, MonadThrow m) => (a -> b) -> (a -> m b)

-- | handles the following exceptions:
--   
--   <ul>
--   <li><a>ArithException</a></li>
--   <li><a>ArrayException</a></li>
--   <li><a>ErrorCall</a></li>
--   <li><a>PatternMatchFail</a></li>
--   </ul>
defaultPartialityHandlers :: (MonadThrow m) => [Handler (m a)]

-- | Evaluate a value to normal form and <a>throwM</a> any exceptions are
--   thrown during evaluation. For any error-free value, <tt>spoon =
--   Just</tt>.
--   
--   (taken from the <a>spoon</a> package.)
spoonWith :: (NFData a, MonadThrow m) => [Handler (m a)] -> a -> m a

-- | the eliminator as a function and the introducer as a string
--   
--   helper for declaring Show instances of datatypes without visible
--   constructors (like <tt>Map</tt> which is shown as a list).
showsPrecWith :: (Show b) => String -> (a -> b) -> Int -> a -> ShowS

module Enumerate.Function.Types

-- | see "Enumerate.Function.Reify.getJectivityM"
data Jectivity
Injective :: Jectivity
Surjective :: Jectivity
Bijective :: Jectivity

-- | a (safely-)partial function. i.e. a function that:
--   
--   <ul>
--   <li>fails only via the <tt>throwM</tt> method of
--   <a>MonadThrow</a></li>
--   <li>succeeds only via the <a>return</a> method of <a>Monad</a></li>
--   </ul>
type Partial a b = forall m. MonadThrow m => a -> m b
type (-?>) a b = Partial a b
instance GHC.Generics.Constructor Enumerate.Function.Types.C1_2Jectivity
instance GHC.Generics.Constructor Enumerate.Function.Types.C1_1Jectivity
instance GHC.Generics.Constructor Enumerate.Function.Types.C1_0Jectivity
instance GHC.Generics.Datatype Enumerate.Function.Types.D1Jectivity
instance Enumerate.Types.Enumerable Enumerate.Function.Types.Jectivity
instance Control.DeepSeq.NFData Enumerate.Function.Types.Jectivity
instance Data.Data.Data Enumerate.Function.Types.Jectivity
instance GHC.Generics.Generic Enumerate.Function.Types.Jectivity
instance GHC.Arr.Ix Enumerate.Function.Types.Jectivity
instance GHC.Enum.Bounded Enumerate.Function.Types.Jectivity
instance GHC.Enum.Enum Enumerate.Function.Types.Jectivity
instance GHC.Classes.Ord Enumerate.Function.Types.Jectivity
instance GHC.Classes.Eq Enumerate.Function.Types.Jectivity
instance GHC.Read.Read Enumerate.Function.Types.Jectivity
instance GHC.Show.Show Enumerate.Function.Types.Jectivity


-- | see <a>reifyFunctionAtM</a>.
--   
--   <pre>
--   -- doctest
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :set +m
--   </pre>
module Enumerate.Function.Reify

-- | reify a total function.
--   
--   <pre>
--   &gt;&gt;&gt; reifyFunction not  -- Prelude <a>not</a>
--   [(False,True),(True,False)]
--   </pre>
reifyFunction :: (Enumerable a) => (a -> b) -> [(a, b)]

-- | reify a total function at any subset of the domain.
reifyFunctionAt :: [a] -> (a -> b) -> [(a, b)]

-- | reify a (safely-)partial function into a map (which is implicitly
--   partial, where <tt>Map.lookup</tt> is like <tt>($)</tt>.
reifyFunctionM :: (Enumerable a) => (forall m. MonadThrow m => a -> m b) -> [(a, b)]

-- | reify a (safely-)partial function at any domain.
--   
--   use the functions suffixed with <tt>M</tt> when your function is
--   explicitly partial, i.e. of type <tt>(forall m. MonadThrow m =&gt; a
--   -&gt; m b)</tt>. when inside a function arrow, like:
--   
--   <pre>
--   reifyFunctionAtM :: [a] -&gt; (forall m. MonadThrow m =&gt; a -&gt; m b) -&gt; [(a,b)]
--   reifyFunctionAtM domain f = ...
--   </pre>
--   
--   the <tt>Rank2</tt> type (and non-concrete types) means that <tt>f</tt>
--   can only use parametric polymorphic functions, or the methods of the
--   <tt>MonadThrow</tt> class (namely <a>throwM</a>), or methods of
--   <tt>MonadThrow</tt> superclasses (namely <a>return</a>, et cetera).
--   
--   <a>MonadThrow</a> is a class from the <tt>exceptions</tt> package that
--   generalizes failibility. it has instances for <tt>Maybe</tt>,
--   <tt>Either</tt>, <tt>[]</tt>, <tt>IO</tt>, and more.
--   
--   use the functions suffixed with <tt>At</tt> when your domain isn't
--   <a>Enumerable</a>, or when you want to restrict the domain.
--   
--   the most general function in this module.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let uppercasePartial :: (MonadThrow m) =&gt; Char -&gt; m Char
--       uppercasePartial c = case c of
--        'a' -&gt; return 'A'
--        'b' -&gt; return 'B'
--        'z' -&gt; return 'Z'
--        _   -&gt; failed "uppercasePartial"
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reifyFunctionAtM ['a'..'c'] uppercasePartial
--   [(<tt>a</tt>,<tt>A</tt>),(<tt>b</tt>,<tt>B</tt>)]
--   </pre>
--   
--   if your function doesn't fail under <a>MonadThrow</a>, see:
--   
--   <ul>
--   <li><tt>reifyFunctionAtMaybe</tt></li>
--   <li><tt>reifyFunctionAtList</tt></li>
--   <li><tt>reifyFunctionAtEither</tt></li>
--   </ul>
reifyFunctionAtM :: [a] -> (Partial a b) -> [(a, b)]

-- | <pre>
--   reifyPredicateAt = <a>flip</a> <a>filter</a>
--   </pre>
reifyPredicateAt :: [a] -> (a -> Bool) -> [a]

-- | reify a (safely-)partial function that fails specifically under
--   <tt>Maybe</tt>.
reifyFunctionMaybeAt :: [a] -> (a -> Maybe b) -> [(a, b)]

-- | reify a (safely-)partial function that fails specifically under
--   <tt>[]</tt>.
reifyFunctionListAt :: [a] -> (a -> [b]) -> [(a, b)]

-- | reify a (safely-)partial function that fails specifically under
--   <tt>Either SomeException</tt>.
reifyFunctionEitherAt :: [a] -> (a -> Either SomeException b) -> [(a, b)]

-- | reifies an *unsafely*-partial function (i.e. a function that throws
--   exceptions or that has inexhaustive pattern matching).
--   
--   forces the function to be strict.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ratio (Ratio)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmap (1/) [0..3 :: Ratio Integer]
--   [*** Exception: Ratio has zero denominator
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let (1/) = reciprocal
--   
--   &gt;&gt;&gt; reifyFunctionSpoonAt [0..3 :: Ratio Integer] reciprocal
--   [(1 % 1,1 % 1),(2 % 1,1 % 2),(3 % 1,1 % 3)]
--   </pre>
--   
--   normal caveats from violating purity (via <tt>unsafePerformIO</tt>)
--   and from catchalls (via <tt>(e :: SomeExceptions -&gt; _)</tt>) apply.
reifyFunctionSpoonAt :: (NFData b) => [a] -> (a -> b) -> [(a, b)]

-- | reify a binary total function
reifyFunction2 :: (Enumerable a, Enumerable b) => (a -> b -> c) -> [(a, [(b, c)])]

-- | reify a binary total function at some domain
reifyFunction2At :: [a] -> [b] -> (a -> b -> c) -> [(a, [(b, c)])]

-- | reify a binary (safely-)partial function
reifyFunction2M :: (Enumerable a, Enumerable b) => (forall m. MonadThrow m => a -> b -> m c) -> [(a, [(b, c)])]

-- | reify a binary (safely-)partial function at some domain
reifyFunction2AtM :: [a] -> [b] -> (forall m. MonadThrow m => a -> b -> m c) -> [(a, [(b, c)])]

module Enumerate.Function.Invert

-- | convert a total function to a map.
--   
--   <pre>
--   &gt;&gt;&gt; fromFunction not  -- Prelude <a>not</a>
--   fromList [(False,True),(True,False)]
--   </pre>
fromFunction :: (Enumerable a, Ord a) => (a -> b) -> Map a b

-- | convert a (safely-)partial function to a map.
--   
--   wraps <a>reifyFunctionM</a>.
fromFunctionM :: (Enumerable a, Ord a) => (Partial a b) -> Map a b

-- | does the map contain every key in its domain?
--   
--   <pre>
--   &gt;&gt;&gt; isMapTotal (Map.fromList [(False,True),(True,False)])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isMapTotal (Map.fromList [('a',0)])
--   False
--   </pre>
isMapTotal :: (Enumerable a, Ord a) => Map a b -> Bool

-- | safely invert any map.
invertMap :: (Ord a, Ord b) => Map a b -> Map b (NonEmpty a)

-- | the <a>domain</a> of a partial function is the subset of the
--   <a>enumerated</a> input where it's defined.
--   
--   i.e. when <tt>x `member` (domainM f)</tt> then <tt>fromJust (f x)</tt>
--   is defined.
--   
--   <pre>
--   &gt;&gt;&gt; domainM uppercasePartial
--   ['a','b','z']
--   </pre>
domainM :: (Enumerable a) => (Partial a b) -> [a]

-- | (right name?)
--   
--   <pre>
--   corange _ = enumerated
--   </pre>
corange :: (Enumerable a) => (a -> b) -> [a]

-- | <pre>
--   corangeM _ = enumerated
--   </pre>
corangeM :: (Enumerable a) => (Partial a b) -> [a]

-- | the image of a total function.
--   
--   <pre>
--   imageM f = map f <a>enumerated</a>
--   </pre>
--   
--   includes duplicates.
image :: (Enumerable a) => (a -> b) -> [b]

-- | the image (not the <a>codomain</a>) of a partial function.
--   
--   <pre>
--   imageM f = mapMaybe f <a>enumerated</a>
--   </pre>
--   
--   includes duplicates.
imageM :: (Enumerable a) => (Partial a b) -> [b]

-- | the codomain of a function. it contains the <a>image</a>.
--   
--   <pre>
--   codomain _ = enumerated
--   </pre>
codomain :: (Enumerable b) => (a -> b) -> [b]
codomainM :: (Enumerable b) => (Partial a b) -> [b]

-- | invert a total function.
--   
--   <tt>(invert f) b</tt> is:
--   
--   <ul>
--   <li><tt>[]</tt> wherever <tt>f</tt> is not surjective</li>
--   <li><tt>[y]</tt> wherever <tt>f</tt> is uniquely defined</li>
--   <li><tt>(_:_)</tt> wherever <tt>f</tt> is not injective</li>
--   </ul>
--   
--   <pre>
--   invert f = <a>invertM</a> (return.f)
--   </pre>
invert :: (Enumerable a, Ord a, Ord b) => (a -> b) -> (b -> [a])

-- | invert a partial function.
--   
--   <tt>(invertM f) b</tt> is:
--   
--   <ul>
--   <li><tt>[]</tt> wherever <tt>f</tt> is partial</li>
--   <li><tt>[]</tt> wherever <tt>f</tt> is not surjective</li>
--   <li><tt>[y]</tt> wherever <tt>f</tt> is uniquely defined</li>
--   <li><tt>(_:_)</tt> wherever <tt>f</tt> is not injective</li>
--   </ul>
--   
--   a <tt>Map</tt> is stored internally, with as many keys as the
--   <a>image</a> of <tt>f</tt>.
--   
--   see also <a>isBijectiveM</a>.
invertM :: (Enumerable a, Ord a, Ord b) => (Partial a b) -> (b -> [a])
getJectivityM :: (Enumerable a, Enumerable b, Ord a, Ord b) => (Partial a b) -> Maybe Jectivity
isInjective :: (Enumerable a, Ord a, Ord b) => (a -> b) -> Maybe (b -> Maybe a)

-- | returns the inverse of the injection, if injective.
--   
--   refines <tt>(b -&gt; [a])</tt> (i.e. the type of <a>invertM</a>) to
--   <tt>(b -&gt; Maybe a)</tt>.
--   
--   unlike <a>isBijectiveM</a>, doesn't need an <tt>(Enumerable b)</tt>
--   constraint. this helps when you want to ensure a function into an
--   infinite type (e.g. <a>show</a>) is injective. and still reasonably
--   efficient, given the <tt>(Ord b)</tt> constraint.
isInjectiveM :: (Enumerable a, Ord a, Ord b) => (Partial a b) -> Maybe (b -> Maybe a)

-- | converts the list into a set, if it has no duplicates.
isUnique :: (Ord a) => [a] -> Maybe (Set a)
isSurjective :: (Enumerable a, Enumerable b, Ord a, Ord b) => (a -> b) -> Maybe (b -> NonEmpty a)

-- | returns the inverse of the surjection, if surjective. i.e. when a
--   function's <a>codomainM</a> equals its <a>imageM</a>.
--   
--   refines <tt>(b -&gt; [a])</tt> (i.e. the type of <a>invertM</a>) to
--   <tt>(b -&gt; NonEmpty a)</tt>.
--   
--   can short-circuit.
isSurjectiveM :: (Enumerable a, Enumerable b, Ord a, Ord b) => (Partial a b) -> Maybe (b -> NonEmpty a)
isBijective :: (Enumerable a, Enumerable b, Ord a, Ord b) => (a -> b) -> Maybe (b -> a)

-- | returns the inverse of the bijection, if bijective.
--   
--   refines <tt>(b -&gt; [a])</tt> (i.e. the type of <a>invertM</a>) to
--   <tt>(b -&gt; a)</tt>.
--   
--   can short-circuit.
isBijectiveM :: (Enumerable a, Enumerable b, Ord a, Ord b) => (Partial a b) -> Maybe (b -> a)


-- | converting between partial functions and maps.
--   
--   <pre>
--   (for doctest)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :set +m
--   
--   &gt;&gt;&gt; :set -XLambdaCase
--   
--   &gt;&gt;&gt; :{
--   let uppercasePartial :: (MonadThrow m) =&gt; Char -&gt; m Char  -- :: Partial Char Char
--       uppercasePartial = \case
--        'a' -&gt; return 'A'
--        'b' -&gt; return 'B'
--        'z' -&gt; return 'Z'
--        _   -&gt; failed "uppercasePartial"
--   :}
--   </pre>
--   
--   a (safely-)partial function is isomorphic with a <tt>Map</tt>:
--   
--   <pre>
--   <a>fromFunctionM</a> . <a>toFunctionM</a> = <a>id</a>
--   <a>toFunctionM</a> . <a>fromFunctionM</a> = <a>id</a>
--   </pre>
--   
--   modulo the error thrown.
module Enumerate.Function.Map

-- | convert a map to a function, if the map is total.
--   
--   <pre>
--   &gt;&gt;&gt; let (Just not_) = toFunction (Map.fromList [(False,True),(True,False)])
--   
--   &gt;&gt;&gt; not_ False
--   True
--   </pre>
toFunction :: (Enumerable a, Ord a) => Map a b -> Maybe (a -> b)

-- | convert a (safely-)partial function to a map.
--   
--   lookup failures are <a>throwM</a>n as a <a>PatternMatchFail</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let idPartial = toFunctionM (Map.fromList [(True,True)])
--   
--   &gt;&gt;&gt; idPartial True
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; idPartial False
--   *** Exception: toFunctionM
--   </pre>
toFunctionM :: (Enumerable a, Ord a) => Map a b -> (Partial a b)

-- | wraps <a>lookup</a>
unsafeToFunction :: (Ord a) => Map a b -> (a -> b)

-- | refines the partial function, if total.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let myNotM :: Monad m =&gt; Bool -&gt; m Bool
--       myNotM False = return True
--       myNotM True  = return False
--   :}
--   
--   &gt;&gt;&gt; let (Just myNot) = isTotalM myNotM
--   
--   &gt;&gt;&gt; myNot False
--   True
--   </pre>
isTotalM :: (Enumerable a, Ord a) => (Partial a b) -> Maybe (a -> b)

-- | wraps <a>lookup</a>
--   
--   <pre>
--   &gt;&gt;&gt; (unsafeFromList [(False,True),(True,False)]) False
--   True
--   
--   &gt;&gt;&gt; (unsafeFromList [(False,True),(True,False)]) True
--   False
--   </pre>
unsafeFromList :: (Ord a) => [(a, b)] -> (a -> b)

-- | see <a>mappingEnumeratedAt</a>
functionEnumerated :: (Enumerable a, Enumerable b, Ord a, Ord b) => [a -> b]

-- | <pre>
--   |b| ^ |a|
--   </pre>
functionCardinality :: (Enumerable a, Enumerable b) => proxy (a -> b) -> Natural

-- | are all pairs of outputs the same for the same input? (short-ciruits).
extensionallyEqual :: (Enumerable a, Eq b) => (a -> b) -> (a -> b) -> Bool

-- | is any pair of outputs different for the same input? (short-ciruits).
extensionallyUnequal :: (Enumerable a, Eq b) => (a -> b) -> (a -> b) -> Bool

-- | show all inputs and their outputs, as <tt>unsafeFromList [...]</tt>.
functionShowsPrec :: (Enumerable a, Show a, Show b) => Int -> (a -> b) -> ShowS

-- | show all inputs and their outputs, as <tt>case ...</tt>.
displayFunction :: (Enumerable a, Show a, Show b) => (a -> b) -> String
displayInjective :: (Enumerable a, Ord a, Ord b, Show a, Show b) => (a -> b) -> Maybe String

-- | <tt>[(a,b)]</tt> is a mapping, <tt>[[(a,b)]]</tt> is a list of
--   mappings.
--   
--   <pre>
--   &gt;&gt;&gt; let orderingPredicates = mappingEnumeratedAt [LT,EQ,GT] [False,True]
--   
--   &gt;&gt;&gt; print $ length orderingPredicates
--   8
--   
--   &gt;&gt;&gt; printMappings $ orderingPredicates
--   
--   (LT,False)
--   (EQ,False)
--   (GT,False)
--   
--   (LT,False)
--   (EQ,False)
--   (GT,True)
--   
--   (LT,False)
--   (EQ,True)
--   (GT,False)
--   
--   (LT,False)
--   (EQ,True)
--   (GT,True)
--   
--   (LT,True)
--   (EQ,False)
--   (GT,False)
--   
--   (LT,True)
--   (EQ,False)
--   (GT,True)
--   
--   (LT,True)
--   (EQ,True)
--   (GT,False)
--   
--   (LT,True)
--   (EQ,True)
--   (GT,True)
--   </pre>
--   
--   where the (total) mapping:
--   
--   <pre>
--   (LT,False)
--   (EQ,False)
--   (GT,True)
--   </pre>
--   
--   is equivalent to the function:
--   
--   <pre>
--   \case
--    LT -&gt; False
--    EQ -&gt; False
--    GT -&gt; True
--   </pre>
mappingEnumeratedAt :: [a] -> [b] -> [[(a, b)]]

-- | <pre>
--   &gt;&gt;&gt; let crossOrderingBoolean = crossProduct [LT,EQ,GT] [False,True]
--   
--   &gt;&gt;&gt; printMappings $ crossOrderingBoolean
--   
--   (LT,False)
--   (LT,True)
--   
--   (EQ,False)
--   (EQ,True)
--   
--   (GT,False)
--   (GT,True)
--   </pre>
--   
--   the length of the outer list is the size of the first set, and the
--   length of the inner list is the size of the second set.
--   
--   <pre>
--   &gt;&gt;&gt; print $ length crossOrderingBoolean
--   3
--   
--   &gt;&gt;&gt; print $ length (head crossOrderingBoolean)
--   2
--   </pre>
crossProduct :: [a] -> [b] -> [[(a, b)]]


-- | orphan instances, of 'Enumerate'\/'Eq'\/'Show', for functions:
--   
--   <ul>
--   <li><pre>instance (Enumerable a, Enumerable b, Ord a, Ord b) =&gt;
--   Enumerable (a -&gt; b)</pre></li>
--   <li><pre>instance (Enumerable a, Eq b) =&gt; Eq (a -&gt; b)</pre></li>
--   <li><pre>instance (Enumerable a, Show a, Show b) =&gt; Show (a -&gt;
--   b)</pre></li>
--   </ul>
--   
--   see:
--   
--   <ul>
--   <li><a>functionEnumerated</a>, <a>functionCardinality</a></li>
--   <li><a>extensionallyEqual</a>, <a>extensionallyUnequal</a></li>
--   <li><a>functionShowsPrec</a></li>
--   </ul>
--   
--   (that are included for completeness, but not exported by default (i.e.
--   by <a>Enumerate</a>). you probably want build-time instance-resolution
--   errors, rather than possible runtime non-termination).
--   
--   <pre>
--   -- doctest
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XLambdaCase
--   </pre>
module Enumerate.Orphans.Function

-- | the exponential type.
--   
--   the <a>cardinality</a> is the cardinality of <tt>b</tt> raised to the
--   cardinality <tt>a</tt>, i.e. <tt>|b|^|a|</tt>.
--   
--   warning: it grows very quickly.
--   
--   might be useful for generating random functions on small types, like
--   to fuzz test type class laws.
--   
--   the <a>cardinality</a> call is efficient (depending on the efficiency
--   of the base type's call). you should be able to safely (WRT
--   performance) call <a>enumerateBelow</a>, unless the arithmetic itself
--   becomes too expensive.
--   
--   <pre>
--   instance (<a>Enumerable</a> a, Enumerable b, <a>Ord</a> a, Ord b) =&gt; Enumerable (a -&gt; b) where
--    enumerated = <a>functionEnumerated</a>
--   </pre>

-- | brute-force function extensionality.
--   
--   warning: the size of the domain grows exponentially in the number of
--   arguments.
--   
--   <pre>
--   &gt;&gt;&gt; (\case LT -&gt; False; EQ -&gt; False; GT -&gt; False) == const False
--   True
--   
--   &gt;&gt;&gt; (\case LT -&gt; False; EQ -&gt; False; GT -&gt; False) == const True
--   False
--   </pre>
--   
--   because functions are curried, the instance is recursive, and it works
--   on functions of any arity:
--   
--   <pre>
--    -- De Morgan's laws
--   &gt;&gt; (\x y -&gt; not (x &amp;&amp; y)) == (\x y -&gt; not x || not y)
--   </pre>
--   
--   True &gt;&gt;&gt; (x y -&gt; not (x || y)) == (x y -&gt; not x
--   &amp;&amp; not y) True

-- | <ul>
--   <li>- &gt;&gt;&gt; not</li>
--   <li>- unsafeFromList [(False,True),(True,False)]</li>
--   </ul>
--   
--   because functions are curried, the instance is recursive, and it works
--   on functions of any arity:
--   
--   <ul>
--   <li>- &gt;&gt;&gt; (&amp;&amp;)</li>
--   <li>- unsafeFromList [(False,unsafeFromList
--   [(False,False),(True,False)]),(True,unsafeFromList
--   [(False,False),(True,True)])]</li>
--   </ul>
instance (Enumerate.Types.Enumerable a, Enumerate.Types.Enumerable b, GHC.Classes.Ord a, GHC.Classes.Ord b) => Enumerate.Types.Enumerable (a -> b)
instance (Enumerate.Types.Enumerable a, GHC.Classes.Eq b) => GHC.Classes.Eq (a -> b)
instance (Enumerate.Types.Enumerable a, GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a -> b)


-- | e.g.
--   
--   <ol>
--   <li>given:</li>
--   </ol>
--   
--   <pre>
--   data Edit = Edit Action Slice Region
--    deriving (Show,Read,Eq,Ord,Generic,Enumerable)
--   
--   data Action
--    = Transpose
--    | Copy
--    | Delete
--    deriving (Show,Read,Eq,Ord,Enum,Bounded,Generic,Enumerable)
--   
--   data Slice
--    = Whole
--    | Backwards
--    | Forwards
--    deriving (Show,Read,Eq,Ord,Enum,Bounded,Generic,Enumerable)
--   
--   data Region
--    = Character
--    | Token
--    | Line
--    deriving (Show,Read,Eq,Ord,Enum,Bounded,Generic,Enumerable)
--   </pre>
--   
--   we can enumerate every possible editing action:
--   
--   <pre>
--   &gt; <tt>enumerated</tt> :: [Edit]
--   </pre>
--   
--   <ol>
--   <li>given a mapping to keyboard shortcuts within emacs:</li>
--   </ol>
--   
--   <pre>
--   type KeyBinding = [String]
--   emacsEdit :: Edit -&gt; KeyBinding
--   </pre>
--   
--   the `enumerate-function` package can:
--   
--   <ul>
--   <li>verify that <tt>emacsEdit</tt> doesn't map different editing
--   actions to the same keybindings, which would mean that one would
--   shadow the other i.e. it has no collisions; i.e. it's is
--   injective.</li>
--   <li>TODO verify that <tt>emacsEdit</tt> maps every editing action to
--   some keybinding, which asserts that the relevant application supports
--   <tt>Edit</tt>ing in its entirety. (e.g. <tt>Emacs</tt> can,
--   <tt>Chrome</tt> can't); i.e. it's is surjective.</li>
--   <li>detect whether <tt>emacsEdit</tt> is actually total; i.e. free of
--   bottoms. Haskell's exhaustivity checker (enable `-Wall`) can verify
--   the totality of <tt>emacsEdit</tt>, assuming no partial
--   functions.</li>
--   <li>serialize <tt>emacsEdit</tt> into a mapping, from which
--   <tt>elisp</tt> source can be extracted.</li>
--   </ul>
--   
--   (also see the source of <a>Enumerate.Function.Example</a>)
module Enumerate.Function


module Enumerate.Function.Example
main :: IO ()
data Edit
Edit :: Action -> Slice -> Region -> Edit
data Action
Cut :: Action
Delete :: Action
Transpose :: Action
data Slice
Whole :: Slice
Backwards :: Slice
Forwards :: Slice
data Region
Character :: Region
Token :: Region
Line :: Region
type KeyBinding = [String]
emacsEdit :: Edit -> KeyBinding
emacsTranspose :: Region -> KeyBinding
emacsSelect :: Region -> Slice -> KeyBinding
emacsBeginRegion :: Region -> KeyBinding
emacsEndRegion :: Region -> KeyBinding
instance GHC.Generics.Constructor Enumerate.Function.Example.C1_0Edit
instance GHC.Generics.Datatype Enumerate.Function.Example.D1Edit
instance GHC.Generics.Constructor Enumerate.Function.Example.C1_2Region
instance GHC.Generics.Constructor Enumerate.Function.Example.C1_1Region
instance GHC.Generics.Constructor Enumerate.Function.Example.C1_0Region
instance GHC.Generics.Datatype Enumerate.Function.Example.D1Region
instance GHC.Generics.Constructor Enumerate.Function.Example.C1_2Slice
instance GHC.Generics.Constructor Enumerate.Function.Example.C1_1Slice
instance GHC.Generics.Constructor Enumerate.Function.Example.C1_0Slice
instance GHC.Generics.Datatype Enumerate.Function.Example.D1Slice
instance GHC.Generics.Constructor Enumerate.Function.Example.C1_2Action
instance GHC.Generics.Constructor Enumerate.Function.Example.C1_1Action
instance GHC.Generics.Constructor Enumerate.Function.Example.C1_0Action
instance GHC.Generics.Datatype Enumerate.Function.Example.D1Action
instance Enumerate.Types.Enumerable Enumerate.Function.Example.Edit
instance GHC.Generics.Generic Enumerate.Function.Example.Edit
instance GHC.Classes.Ord Enumerate.Function.Example.Edit
instance GHC.Classes.Eq Enumerate.Function.Example.Edit
instance GHC.Read.Read Enumerate.Function.Example.Edit
instance GHC.Show.Show Enumerate.Function.Example.Edit
instance Enumerate.Types.Enumerable Enumerate.Function.Example.Region
instance GHC.Generics.Generic Enumerate.Function.Example.Region
instance GHC.Enum.Bounded Enumerate.Function.Example.Region
instance GHC.Enum.Enum Enumerate.Function.Example.Region
instance GHC.Classes.Ord Enumerate.Function.Example.Region
instance GHC.Classes.Eq Enumerate.Function.Example.Region
instance GHC.Read.Read Enumerate.Function.Example.Region
instance GHC.Show.Show Enumerate.Function.Example.Region
instance Enumerate.Types.Enumerable Enumerate.Function.Example.Slice
instance GHC.Generics.Generic Enumerate.Function.Example.Slice
instance GHC.Enum.Bounded Enumerate.Function.Example.Slice
instance GHC.Enum.Enum Enumerate.Function.Example.Slice
instance GHC.Classes.Ord Enumerate.Function.Example.Slice
instance GHC.Classes.Eq Enumerate.Function.Example.Slice
instance GHC.Read.Read Enumerate.Function.Example.Slice
instance GHC.Show.Show Enumerate.Function.Example.Slice
instance Enumerate.Types.Enumerable Enumerate.Function.Example.Action
instance GHC.Generics.Generic Enumerate.Function.Example.Action
instance GHC.Enum.Bounded Enumerate.Function.Example.Action
instance GHC.Enum.Enum Enumerate.Function.Example.Action
instance GHC.Classes.Ord Enumerate.Function.Example.Action
instance GHC.Classes.Eq Enumerate.Function.Example.Action
instance GHC.Read.Read Enumerate.Function.Example.Action
instance GHC.Show.Show Enumerate.Function.Example.Action
