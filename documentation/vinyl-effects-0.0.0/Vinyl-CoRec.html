<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Vinyl.CoRec</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Vinyl-CoRec.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Vinyl-CoRec.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">vinyl-effects-0.0.0: TODO</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Vinyl.CoRec</p></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:CoRec">CoRec</a> :: (k -&gt; *) -&gt; [k] -&gt; * <span class="keyword">where</span><ul class="subs"><li><a href="#v:Col">Col</a> :: t <a href="../vinyl-0.5.2/Data-Vinyl-Lens.html#t:-8712-">&#8712;</a> ts =&gt; !(f t) -&gt; <a href="Vinyl-CoRec.html#t:CoRec">CoRec</a> f ts</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:OneOf">OneOf</a> = <a href="Vinyl-CoRec.html#t:CoRec">CoRec</a> <a href="../vinyl-0.5.2/Data-Vinyl-Functor.html#t:Identity">Identity</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Outputs">Outputs</a> b a = <a href="#v:O">O</a> {<ul class="subs"><li><a href="#v:runOutputs">runOutputs</a> :: a -&gt; b</li></ul>}</li><li class="src short"><span class="keyword">type</span> <a href="#t:-60--45--45-">(&lt;--)</a> = <a href="Vinyl-CoRec.html#t:Outputs">Outputs</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Handlers">Handlers</a> f b as = <a href="../vinyl-0.5.2/Data-Vinyl-Core.html#t:Rec">Rec</a> (<a href="Vinyl-CoRec.html#t:Handler">Handler</a> f b) as</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Handler">Handler</a> f b a = <a href="#v:H">H</a> {<ul class="subs"><li><a href="#v:runHandler">runHandler</a> :: f a -&gt; b</li></ul>}</li><li class="src short"><a href="#v:column">column</a> :: t <a href="../vinyl-0.5.2/Data-Vinyl-Lens.html#t:-8712-">&#8712;</a> ts =&gt; t -&gt; <a href="Vinyl-CoRec.html#t:OneOf">OneOf</a> ts</li><li class="src short"><a href="#v:outputs2handler">outputs2handler</a> :: <a href="Vinyl-CoRec.html#t:Outputs">Outputs</a> b a -&gt; <a href="Vinyl-CoRec.html#t:Handler">Handler</a> <a href="../vinyl-0.5.2/Data-Vinyl-Functor.html#t:Identity">Identity</a> b a</li><li class="src short"><a href="#v:fromUnitCoRec">fromUnitCoRec</a> :: <a href="Vinyl-CoRec.html#t:CoRec">CoRec</a> f `[a]` -&gt; f a</li><li class="src short"><a href="#v:toUnitCoRec">toUnitCoRec</a> :: f a -&gt; <a href="Vinyl-CoRec.html#t:CoRec">CoRec</a> f `[a]`</li><li class="src short"><a href="#v:handle">handle</a> :: <a href="../vinyl-0.5.2/Data-Vinyl-Core.html#t:Rec">Rec</a> (<a href="Vinyl-CoRec.html#t:Handler">Handler</a> f b) as -&gt; <a href="Vinyl-CoRec.html#t:CoRec">CoRec</a> f as -&gt; b</li><li class="src short"><a href="#v:unitHandlers">unitHandlers</a> :: <a href="../vinyl-0.5.2/Data-Vinyl-Core.html#t:Rec">Rec</a> (<a href="Vinyl-CoRec.html#t:Handler">Handler</a> f (f a)) `[a]`</li><li class="src short"><a href="#v:match">match</a> :: <a href="../vinyl-0.5.2/Data-Vinyl-Core.html#t:Rec">Rec</a> (<a href="Vinyl-CoRec.html#t:Outputs">Outputs</a> b) as -&gt; <a href="Vinyl-CoRec.html#t:OneOf">OneOf</a> as -&gt; b</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:CoRec" class="def">CoRec</a> :: (k -&gt; *) -&gt; [k] -&gt; * <span class="keyword">where</span> <a href="src/Vinyl-CoRec.html#CoRec" class="link">Source</a></p><div class="doc"><p>Generalize algebraic sum types.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Col" class="def">Col</a> :: t <a href="../vinyl-0.5.2/Data-Vinyl-Lens.html#t:-8712-">&#8712;</a> ts =&gt; !(f t) -&gt; <a href="Vinyl-CoRec.html#t:CoRec">CoRec</a> f ts</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:CoRec" class="caption collapser" onclick="toggleSection('i:CoRec')">Instances</p><div id="section.i:CoRec" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Text-Show.html#t:Show">Show</a> (<a href="Vinyl-CoRec.html#t:CoRec">CoRec</a> * (<a href="../vinyl-0.5.2/Data-Vinyl-Core.html#t:Dict">Dict</a> <a href="../base-4.8.2.0/Text-Show.html#t:Show">Show</a>) ts)</span> <a href="src/Vinyl-CoRec.html#line-35" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:OneOf" class="def">OneOf</a> = <a href="Vinyl-CoRec.html#t:CoRec">CoRec</a> <a href="../vinyl-0.5.2/Data-Vinyl-Functor.html#t:Identity">Identity</a> <a href="src/Vinyl-CoRec.html#OneOf" class="link">Source</a></p><div class="doc"><p>a value of type <code>OneOf [x,y,z]</code> holds a value of one of the types, either <code>x</code> or <code>y</code> or <code>z</code>.</p></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Outputs" class="def">Outputs</a> b a <a href="src/Vinyl-CoRec.html#Outputs" class="link">Source</a></p><div class="doc"><p>A function type constructor that takes its arguments in the reverse order.</p><p>without type lambdas, we need a type constructor to reorder type parameters.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:O" class="def">O</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:runOutputs" class="def">runOutputs</a> :: a -&gt; b</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:-60--45--45-" class="def">(&lt;--)</a> = <a href="Vinyl-CoRec.html#t:Outputs">Outputs</a> <a href="src/Vinyl-CoRec.html#%3C--" class="link">Source</a></p><div class="doc"><p><code>(b &lt;-- a)</code> is isomorphic to <code>(a -&gt; b)</code>.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Handlers" class="def">Handlers</a> f b as = <a href="../vinyl-0.5.2/Data-Vinyl-Core.html#t:Rec">Rec</a> (<a href="Vinyl-CoRec.html#t:Handler">Handler</a> f b) as <a href="src/Vinyl-CoRec.html#Handlers" class="link">Source</a></p><div class="doc"><p>a product of handlers.</p></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Handler" class="def">Handler</a> f b a <a href="src/Vinyl-CoRec.html#Handler" class="link">Source</a></p><div class="doc"><p>a flipped <code>CoKleisli</code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:H" class="def">H</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:runHandler" class="def">runHandler</a> :: f a -&gt; b</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:column" class="def">column</a> :: t <a href="../vinyl-0.5.2/Data-Vinyl-Lens.html#t:-8712-">&#8712;</a> ts =&gt; t -&gt; <a href="Vinyl-CoRec.html#t:OneOf">OneOf</a> ts <a href="src/Vinyl-CoRec.html#column" class="link">Source</a></p><div class="doc"><p>helper to build a <code><a href="Vinyl-CoRec.html#t:OneOf">OneOf</a></code></p></div></div><div class="top"><p class="src"><a name="v:outputs2handler" class="def">outputs2handler</a> :: <a href="Vinyl-CoRec.html#t:Outputs">Outputs</a> b a -&gt; <a href="Vinyl-CoRec.html#t:Handler">Handler</a> <a href="../vinyl-0.5.2/Data-Vinyl-Functor.html#t:Identity">Identity</a> b a <a href="src/Vinyl-CoRec.html#outputs2handler" class="link">Source</a></p><div class="doc"><p>Handler generalizes Outputs.</p></div></div><div class="top"><p class="src"><a name="v:fromUnitCoRec" class="def">fromUnitCoRec</a> :: <a href="Vinyl-CoRec.html#t:CoRec">CoRec</a> f `[a]` -&gt; f a <a href="src/Vinyl-CoRec.html#fromUnitCoRec" class="link">Source</a></p><div class="doc"><p>inverse with <code><a href="Vinyl-CoRec.html#v:toUnitCoRec">toUnitCoRec</a></code></p></div></div><div class="top"><p class="src"><a name="v:toUnitCoRec" class="def">toUnitCoRec</a> :: f a -&gt; <a href="Vinyl-CoRec.html#t:CoRec">CoRec</a> f `[a]` <a href="src/Vinyl-CoRec.html#toUnitCoRec" class="link">Source</a></p><div class="doc"><p>inverse with <code><a href="Vinyl-CoRec.html#v:fromUnitCoRec">fromUnitCoRec</a></code></p></div></div><div class="top"><p class="src"><a name="v:handle" class="def">handle</a> :: <a href="../vinyl-0.5.2/Data-Vinyl-Core.html#t:Rec">Rec</a> (<a href="Vinyl-CoRec.html#t:Handler">Handler</a> f b) as -&gt; <a href="Vinyl-CoRec.html#t:CoRec">CoRec</a> f as -&gt; b <a href="src/Vinyl-CoRec.html#handle" class="link">Source</a></p><div class="doc"><p>you consume a coproduct with a product of consumers i.e. you must handle every case.</p><p>generalizes <code><a href="Vinyl-CoRec.html#v:match">match</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:unitHandlers" class="def">unitHandlers</a> :: <a href="../vinyl-0.5.2/Data-Vinyl-Core.html#t:Rec">Rec</a> (<a href="Vinyl-CoRec.html#t:Handler">Handler</a> f (f a)) `[a]` <a href="src/Vinyl-CoRec.html#unitHandlers" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:match" class="def">match</a> :: <a href="../vinyl-0.5.2/Data-Vinyl-Core.html#t:Rec">Rec</a> (<a href="Vinyl-CoRec.html#t:Outputs">Outputs</a> b) as -&gt; <a href="Vinyl-CoRec.html#t:OneOf">OneOf</a> as -&gt; b <a href="src/Vinyl-CoRec.html#match" class="link">Source</a></p><div class="doc"><p>perform &quot;pattern matching&quot; upon a CoRec.</p><p>a generalized, uncurried, newtyped version of:</p><pre><code><a href="../base-4.8.2.0/Data-Either.html#v:either">either</a></code> :: (a1 -&gt; b) -&gt; (a2 -&gt; b) -&gt; Either a b
</pre><p>e.g.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set +m
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Vinyl
</code></strong></pre><p>truthy is like a final method (i.e. different definitions can be dispatched on a fixed set of different types):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>let truthy :: Rec (Outputs Bool) [Int, String, Bool]
    truthy =  (O$ \i -&gt; i==0)
           :&amp; (O$ \s -&gt; s==&quot;&quot;)
           :&amp; (O$ \b -&gt; b)
           :&amp; RNil
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>match truthy (column True       :: OneOf [Int,String,Bool])
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>match truthy (column &quot;nonempty&quot; :: OneOf [Int,String,Bool])
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>match truthy (column (1::Int)   :: OneOf [Int,String,Bool])
</code></strong>True
</pre><p>the integer literal needs a type signature (numeric literals are overloaded) because Haskell can't prove that <code>(Num t, t &#8712; [Int,String,Bool])</code>. but it can prove <code>(Int &#8712; [Int,String,Bool])</code>. with <code>ExtendedDefaultRules</code>, the type variables can be defaulted. the same problem (and solutions) exists for string literals with <code>OverloadedStrings</code>, and for list literals with <code>OverloadedLists</code>.</p><p>type inference does work when the <code><a href="Vinyl-CoRec.html#v:column">column</a></code> is immediately consumed@:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>match truthy (column False)
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>match truthy (column &quot;&quot;)
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>match truthy (column (0::Int))
</code></strong>False
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>