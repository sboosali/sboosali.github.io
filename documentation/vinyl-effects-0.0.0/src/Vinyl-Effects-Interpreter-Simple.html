<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>sources/Vinyl/Effects/Interpreter/Simple.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE ConstraintKinds, KindSignatures, DataKinds, RankNTypes #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-comment'>{-|
<a name="line-4"></a>
<a name="line-5"></a>Making interpreters:
<a name="line-6"></a>
<a name="line-7"></a>* 'singletonInterpreter', from a handler
<a name="line-8"></a>
<a name="line-9"></a>Growing interpreters:
<a name="line-10"></a>
<a name="line-11"></a>* 'appendInterpreters'
<a name="line-12"></a>
<a name="line-13"></a>Shrinking an interpreter:
<a name="line-14"></a>
<a name="line-15"></a>* 'downcastInterpreter', when it handles more than you need
<a name="line-16"></a>
<a name="line-17"></a>If you want to do more with them,
<a name="line-18"></a>just unwrap the @newtype@ and use "Data.Vinyl".
<a name="line-19"></a>
<a name="line-20"></a>-}</span>
<a name="line-21"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Vinyl</span><span class='hs-varop'>.</span><span class='hs-conid'>Effects</span><span class='hs-varop'>.</span><span class='hs-conid'>Interpreter</span><span class='hs-varop'>.</span><span class='hs-conid'>Simple</span> <span class='hs-keyword'>where</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Vinyl</span><span class='hs-varop'>.</span><span class='hs-conid'>Effects</span><span class='hs-varop'>.</span><span class='hs-conid'>Types</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Vinyl</span><span class='hs-varop'>.</span><span class='hs-conid'>Effects</span><span class='hs-varop'>.</span><span class='hs-conid'>Language</span>
<a name="line-24"></a><span class='hs-comment'>-- import Vinyl.Effects.Extra</span>
<a name="line-25"></a>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Vinyl</span><span class='hs-varop'>.</span><span class='hs-conid'>CoRec</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Vinyl</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Vinyl</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeLevel</span>
<a name="line-29"></a><span class='hs-comment'>-- import Data.Coerce</span>
<a name="line-30"></a>
<a name="line-31"></a><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<a name="line-32"></a>
<a name="line-33"></a><a name="Interpreter"></a><span class='hs-comment'>{-| a product of handlers.
<a name="line-34"></a>
<a name="line-35"></a>each field holds a co-algebra:
<a name="line-36"></a>
<a name="line-37"></a>@
<a name="line-38"></a>f (m a) -&gt; m a
<a name="line-39"></a>@
<a name="line-40"></a>
<a name="line-41"></a>e.g.
<a name="line-42"></a>
<a name="line-43"></a>@
<a name="line-44"></a>runFG :: Interpreter IO '[f,g]
<a name="line-45"></a>runFG = Interpreter $ 'HandlerM' runF :&amp; 'HandlerM' runG :&amp; RNil
<a name="line-46"></a>
<a name="line-47"></a>runF :: f (m a) -&gt; m a
<a name="line-48"></a>
<a name="line-49"></a>runG :: g (m a) -&gt; m a
<a name="line-50"></a>@
<a name="line-51"></a>
<a name="line-52"></a>specialization:
<a name="line-53"></a>
<a name="line-54"></a>@
<a name="line-55"></a>Interpreter IO [f,g]
<a name="line-56"></a>~
<a name="line-57"></a>Rec ('HandlerM' IO) [f,g]
<a name="line-58"></a>~
<a name="line-59"></a>(HandlerM IO f, HandlerM IO g)
<a name="line-60"></a>~
<a name="line-61"></a>( (forall x. f (IO x) -&gt; IO x)
<a name="line-62"></a>, (forall y. g (IO y) -&gt; IO y)
<a name="line-63"></a>)
<a name="line-64"></a>@
<a name="line-65"></a>
<a name="line-66"></a>-}</span>
<a name="line-67"></a><a name="Interpreter"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>Interpreter</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>*</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varop'>*</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>effects</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varop'>*</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varop'>*</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Interpreter</span> <span class='hs-layout'>{</span> <span class='hs-varid'>getInterpreter</span> <span class='hs-keyglyph'>::</span>
<a name="line-68"></a> <span class='hs-conid'>Rec</span> <span class='hs-layout'>(</span><span class='hs-conid'>HandlerM</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>effects</span>
<a name="line-69"></a> <span class='hs-layout'>}</span>
<a name="line-70"></a>
<a name="line-71"></a><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<a name="line-72"></a>
<a name="line-73"></a><a name="HandlerM"></a><span class='hs-comment'>{-| monadically handle a functor.
<a name="line-74"></a>
<a name="line-75"></a>-}</span>
<a name="line-76"></a><a name="HandlerM"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>HandlerM</span> <span class='hs-varid'>m</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HandlerM</span> <span class='hs-layout'>{</span> <span class='hs-varid'>getHandlerM</span> <span class='hs-keyglyph'>::</span>
<a name="line-77"></a> <span class='hs-keyword'>forall</span> <span class='hs-varid'>x</span><span class='hs-varop'>.</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>x</span>
<a name="line-78"></a> <span class='hs-layout'>}</span>
<a name="line-79"></a>
<a name="line-80"></a><span class='hs-comment'>-- {-|</span>
<a name="line-81"></a><span class='hs-comment'>--</span>
<a name="line-82"></a><span class='hs-comment'>-- -}</span>
<a name="line-83"></a><span class='hs-comment'>-- newtype Handler f = Handler { getHandler ::</span>
<a name="line-84"></a><span class='hs-comment'>--  forall x. f x -&gt; x</span>
<a name="line-85"></a><span class='hs-comment'>--  }</span>
<a name="line-86"></a><span class='hs-comment'>-- TODO Conflicts with co-records</span>
<a name="line-87"></a>
<a name="line-88"></a><span class='hs-comment'>--old type HandlerM m a f = Handler f (m a) (m a)</span>
<a name="line-89"></a>
<a name="line-90"></a><span class='hs-comment'>{-old
<a name="line-91"></a>
<a name="line-92"></a>each field holds a natural transformation:
<a name="line-93"></a>
<a name="line-94"></a>f (m a) -&gt;
<a name="line-95"></a>
<a name="line-96"></a>-}</span>
<a name="line-97"></a>
<a name="line-98"></a><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<a name="line-99"></a>
<a name="line-100"></a><a name="ProductF"></a><span class='hs-comment'>{-| A (1) lifted, (2) n-ary, (3) associative product.
<a name="line-101"></a>
<a name="line-102"></a>In particular, a @product@ of "handlers".
<a name="line-103"></a>
<a name="line-104"></a>@fs@ must all be @Functor@s.
<a name="line-105"></a>
<a name="line-106"></a>e.g.
<a name="line-107"></a>
<a name="line-108"></a>@
<a name="line-109"></a>ProductF [f,g] a
<a name="line-110"></a>@
<a name="line-111"></a>
<a name="line-112"></a>generalizes '(,)':
<a name="line-113"></a>
<a name="line-114"></a>@
<a name="line-115"></a>ProductF '[f,g] a
<a name="line-116"></a>~
<a name="line-117"></a>(f a, g a)
<a name="line-118"></a>@
<a name="line-119"></a>
<a name="line-120"></a>-}</span>
<a name="line-121"></a><a name="ProductF"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ProductF</span> <span class='hs-varid'>fs</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ProductF</span> <span class='hs-layout'>{</span> <span class='hs-varid'>getProductF</span> <span class='hs-keyglyph'>::</span>
<a name="line-122"></a> <span class='hs-conid'>Rec</span> <span class='hs-layout'>(</span><span class='hs-conid'>Apply</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>fs</span>
<a name="line-123"></a> <span class='hs-layout'>}</span>
<a name="line-124"></a>
<a name="line-125"></a><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<a name="line-126"></a>
<a name="line-127"></a>
<a name="line-128"></a><a name="interpretLanguage"></a><span class='hs-comment'>{-| interpret a language into some monad.
<a name="line-129"></a>
<a name="line-130"></a>e.g.
<a name="line-131"></a>
<a name="line-132"></a>@
<a name="line-133"></a>interpretLanguage anInterpreter aLanguage :: m ()
<a name="line-134"></a>@
<a name="line-135"></a>
<a name="line-136"></a>calls 'iterLM'.
<a name="line-137"></a>
<a name="line-138"></a>-}</span>
<a name="line-139"></a><span class='hs-definition'>interpretLanguage</span>
<a name="line-140"></a> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
<a name="line-141"></a> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-varid'>effects</span>
<a name="line-142"></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Language</span> <span class='hs-varid'>effects</span> <span class='hs-conop'>:~&gt;</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
<a name="line-143"></a><span class='hs-definition'>interpretLanguage</span> <span class='hs-varid'>interpreter</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>iterLM</span> <span class='hs-layout'>(</span><span class='hs-varid'>interpretLanguageF</span> <span class='hs-varid'>interpreter</span><span class='hs-layout'>)</span>
<a name="line-144"></a>
<a name="line-145"></a><span class='hs-comment'>-- {-|</span>
<a name="line-146"></a><span class='hs-comment'>--</span>
<a name="line-147"></a><span class='hs-comment'>-- -}</span>
<a name="line-148"></a><span class='hs-comment'>-- interpretLanguage</span>
<a name="line-149"></a><span class='hs-comment'>--  :: ()</span>
<a name="line-150"></a><span class='hs-comment'>--  =&gt;  Interpreter m effects</span>
<a name="line-151"></a><span class='hs-comment'>--  -&gt; (Language      effects a -&gt; m a)</span>
<a name="line-152"></a><span class='hs-comment'>-- interpretLanguage (Interpreter handlers) (Language features) = m</span>
<a name="line-153"></a><span class='hs-comment'>--  where</span>
<a name="line-154"></a><span class='hs-comment'>--  m = undefined "TODO"</span>
<a name="line-155"></a>
<a name="line-156"></a><a name="interpretLanguageF"></a><span class='hs-comment'>{-| you consume a coproduct with a product of consumers
<a name="line-157"></a>i.e. you must handle every case.
<a name="line-158"></a>
<a name="line-159"></a>like 'match'.
<a name="line-160"></a>
<a name="line-161"></a>-}</span>
<a name="line-162"></a><span class='hs-definition'>interpretLanguageF</span>
<a name="line-163"></a> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-varid'>effects</span>
<a name="line-164"></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnAlgebra</span> <span class='hs-layout'>(</span><span class='hs-conid'>LanguageF</span> <span class='hs-varid'>effects</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-165"></a><span class='hs-definition'>interpretLanguageF</span> <span class='hs-layout'>(</span><span class='hs-conid'>Interpreter</span> <span class='hs-varid'>handlers</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LanguageF</span> <span class='hs-layout'>(</span><span class='hs-conid'>Col</span> <span class='hs-varid'>variant</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-166"></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>h</span> <span class='hs-layout'>(</span><span class='hs-varid'>getApply</span> <span class='hs-varid'>variant</span><span class='hs-layout'>)</span>
<a name="line-167"></a> <span class='hs-keyword'>where</span>
<a name="line-168"></a> <span class='hs-conid'>HandlerM</span> <span class='hs-varid'>h</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rget</span> <span class='hs-varid'>variant</span> <span class='hs-varid'>handlers</span>
<a name="line-169"></a> <span class='hs-comment'>-- pattern matching on `Col` refines the type,</span>
<a name="line-170"></a> <span class='hs-comment'>-- which we index into the handler array,</span>
<a name="line-171"></a> <span class='hs-comment'>-- (@Apply a f@ unifies with @proxy f@),</span>
<a name="line-172"></a> <span class='hs-comment'>-- to access the correct handler.</span>
<a name="line-173"></a>
<a name="line-174"></a><span class='hs-comment'>{-old
<a name="line-175"></a>interpretLanguageF :: Rec (OpCoAlgebra a) fs -&gt; CoRec (Apply a) fs -&gt; a
<a name="line-176"></a>interpretLanguageF handlers (Col variant) = h (getApply variant)
<a name="line-177"></a> where
<a name="line-178"></a> OpCoAlgebra h = rget variant handlers
<a name="line-179"></a>-}</span>
<a name="line-180"></a>
<a name="line-181"></a><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<a name="line-182"></a>
<a name="line-183"></a><a name="singletonInterpreter"></a><span class='hs-comment'>{-| make a interpreter from a single handler.
<a name="line-184"></a>
<a name="line-185"></a>e.g.
<a name="line-186"></a>
<a name="line-187"></a>@
<a name="line-188"></a>data ClipboardF k = GetClipboard (String -&gt; k) | SetClipboard String k deriving Functor
<a name="line-189"></a>
<a name="line-190"></a>clipboardInterpreter :: Interpreter IO '[ClipboardF] a
<a name="line-191"></a>clipboardInterpreter = singletonInterpreter $ \\case
<a name="line-192"></a> GetClipboard f   -&gt; ... &gt;&gt;= f
<a name="line-193"></a> SetClipboard s k -&gt; ... s &gt;&gt; k
<a name="line-194"></a>@
<a name="line-195"></a>
<a name="line-196"></a>-}</span>
<a name="line-197"></a><span class='hs-definition'>singletonInterpreter</span>
<a name="line-198"></a> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>x</span><span class='hs-varop'>.</span> <span class='hs-conid'>AnAlgebra</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-199"></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-chr'>'</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-keyglyph'>]</span>
<a name="line-200"></a><span class='hs-definition'>singletonInterpreter</span> <span class='hs-varid'>h</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>hs</span>
<a name="line-201"></a> <span class='hs-keyword'>where</span>
<a name="line-202"></a> <span class='hs-varid'>hs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HandlerM</span> <span class='hs-varid'>h</span> <span class='hs-conop'>:&amp;</span> <span class='hs-conid'>RNil</span>
<a name="line-203"></a>
<a name="line-204"></a><a name="appendInterpreters"></a><span class='hs-comment'>{- | compose two interpreters. ordered.
<a name="line-205"></a>
<a name="line-206"></a>-}</span>
<a name="line-207"></a><span class='hs-definition'>appendInterpreters</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-varid'>fs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-varid'>gs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-varid'>fs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>gs</span><span class='hs-layout'>)</span>
<a name="line-208"></a><span class='hs-definition'>appendInterpreters</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>asInterpreter2</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;+&gt;</span><span class='hs-layout'>)</span> <span class='hs-comment'>--TODO Can coerce?</span>
<a name="line-209"></a>
<a name="line-210"></a><a name="downcastInterpreter"></a><span class='hs-comment'>{-| Discard any number of handlers from the interpreter.
<a name="line-211"></a>
<a name="line-212"></a>-}</span>
<a name="line-213"></a><span class='hs-definition'>downcastInterpreter</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>gs</span> <span class='hs-sel'>⊆</span> <span class='hs-varid'>fs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-varid'>fs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-varid'>gs</span>
<a name="line-214"></a><span class='hs-definition'>downcastInterpreter</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>asInterpreter1</span> <span class='hs-varid'>rcast</span>  <span class='hs-comment'>--TODO Can coerce?</span>
<a name="line-215"></a>
<a name="line-216"></a><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<a name="line-217"></a>
<a name="line-218"></a><span class='hs-comment'>{-TODO unwrap all rec ops
<a name="line-219"></a>
<a name="line-220"></a>with classes?
<a name="line-221"></a>
<a name="line-222"></a>-}</span>
<a name="line-223"></a>
<a name="line-224"></a><a name="asInterpreter1"></a><span class='hs-comment'>{- | Lift a (unary) function on records to interpreters (a newtype thereof).
<a name="line-225"></a>
<a name="line-226"></a>e.g.
<a name="line-227"></a>
<a name="line-228"></a>@
<a name="line-229"></a>'downcastInterpreter' = asInterpreter1 'rcast'
<a name="line-230"></a>@
<a name="line-231"></a>
<a name="line-232"></a>-}</span>
<a name="line-233"></a><span class='hs-definition'>asInterpreter1</span>
<a name="line-234"></a> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-layout'>(</span><span class='hs-conid'>HandlerM</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>fs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Rec</span> <span class='hs-layout'>(</span><span class='hs-conid'>HandlerM</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>gs</span><span class='hs-layout'>)</span>
<a name="line-235"></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-varid'>fs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-varid'>gs</span><span class='hs-layout'>)</span>
<a name="line-236"></a><span class='hs-definition'>asInterpreter1</span> <span class='hs-varid'>u</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>fs</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-237"></a> <span class='hs-conid'>Interpreter</span> <span class='hs-varop'>$</span> <span class='hs-varid'>u</span> <span class='hs-layout'>(</span><span class='hs-varid'>getInterpreter</span> <span class='hs-varid'>fs</span><span class='hs-layout'>)</span>
<a name="line-238"></a>
<a name="line-239"></a><a name="asInterpreter2"></a><span class='hs-comment'>{- | Lift an operation on records to interpreters (a newtype thereof).
<a name="line-240"></a>
<a name="line-241"></a>e.g.
<a name="line-242"></a>
<a name="line-243"></a>@
<a name="line-244"></a>'appendInterpreters' = asInterpreter2 ('&lt;+&gt;')
<a name="line-245"></a>@
<a name="line-246"></a>
<a name="line-247"></a>-}</span>
<a name="line-248"></a><span class='hs-definition'>asInterpreter2</span>
<a name="line-249"></a> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-layout'>(</span><span class='hs-conid'>HandlerM</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>fs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Rec</span> <span class='hs-layout'>(</span><span class='hs-conid'>HandlerM</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>gs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Rec</span> <span class='hs-layout'>(</span><span class='hs-conid'>HandlerM</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>hs</span><span class='hs-layout'>)</span>
<a name="line-250"></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-varid'>fs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-varid'>gs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-varid'>hs</span><span class='hs-layout'>)</span>
<a name="line-251"></a><span class='hs-definition'>asInterpreter2</span> <span class='hs-varid'>op</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>fs</span> <span class='hs-varid'>gs</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-252"></a> <span class='hs-conid'>Interpreter</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>getInterpreter</span> <span class='hs-varid'>fs</span><span class='hs-layout'>)</span> <span class='hs-varop'>`op`</span> <span class='hs-layout'>(</span><span class='hs-varid'>getInterpreter</span> <span class='hs-varid'>gs</span><span class='hs-layout'>)</span>
<a name="line-253"></a>
<a name="line-254"></a><span class='hs-comment'>{-old
<a name="line-255"></a>:: (Rec (HandlerM m) fs -&gt; Rec (HandlerM m) gs -&gt; Rec (HandlerM m) hs) -- TODO weaker, but clearer: {forall g xs. Rec g xs})
<a name="line-256"></a>
<a name="line-257"></a>:: (forall g as bs cs. Rec g as -&gt; Rec g bs -&gt; Rec g cs)
<a name="line-258"></a>-}</span>
<a name="line-259"></a>
<a name="line-260"></a><span class='hs-comment'>{-err
<a name="line-261"></a>appendInterpreters = coerce (&lt;+&gt;)
<a name="line-262"></a>
<a name="line-263"></a>Couldn't match representation of type ‘Rec f0 (as0 ++ bs0)’
<a name="line-264"></a>                         with that of ‘Interpreter m (fs ++ gs) a’
<a name="line-265"></a>arising from trying to show that the representations of
<a name="line-266"></a>  ‘Rec f0 as0 -&gt; Rec f0 bs0 -&gt; Rec f0 (as0 ++ bs0)’ and
<a name="line-267"></a>  ‘Interpreter m fs a
<a name="line-268"></a>   -&gt; Interpreter m gs a -&gt; Interpreter m (fs ++ gs) a’ are the same
<a name="line-269"></a>Relevant role signatures:
<a name="line-270"></a> type role Rec nominal representational nominal
<a name="line-271"></a> type role ++ nominal nominal nominal
<a name="line-272"></a> type role Interpreter nominal nominal nominal
<a name="line-273"></a>-}</span>
<a name="line-274"></a>
<a name="line-275"></a><a name="fromSingletonInterpreter"></a><span class='hs-comment'>{-| inverts 'singletonInterpreter', for convenient access.
<a name="line-276"></a>
<a name="line-277"></a>-}</span>
<a name="line-278"></a><span class='hs-definition'>fromSingletonInterpreter</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Interpreter</span> <span class='hs-varid'>m</span> <span class='hs-chr'>'</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnAlgebra</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-279"></a><span class='hs-definition'>fromSingletonInterpreter</span> <span class='hs-layout'>(</span><span class='hs-conid'>Interpreter</span> <span class='hs-layout'>(</span><span class='hs-conid'>HandlerM</span> <span class='hs-varid'>h</span> <span class='hs-conop'>:&amp;</span> <span class='hs-conid'>RNil</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>h</span>
<a name="line-280"></a><span class='hs-comment'>--TODO spurious non-exhaustive</span>
<a name="line-281"></a>
<a name="line-282"></a><span class='hs-comment'>--------------------------------------------------------------------------------</span>
</pre></body>
</html>
