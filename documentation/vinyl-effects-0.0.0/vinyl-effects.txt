-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | TODO
--   
--   TODO
@package vinyl-effects
@version 0.0.0


module Vinyl.Effects.Interpreter.Cofree

module Vinyl.Effects.Extra
nothing :: (Monad m) => m ()


-- | shared types.
module Vinyl.Effects.Types

-- | <tt>Apply a</tt> is a type-level <tt>(<a>$</a> a)</tt>.
--   
--   <tt>f</tt> must be a <tt>Functor</tt>.
data Apply a f
Apply :: f a -> Apply a f
getApply :: Apply a f -> f a

-- | An algebra.
type AnAlgebra f a = f a -> a
newtype Algebra f a
Algebra :: AnAlgebra f a -> Algebra f a
[getAlgebra] :: Algebra f a -> AnAlgebra f a

-- | a co-algebra (with the two types in reverse order).
newtype OpAlgebra a f
OpAlgebra :: AnAlgebra f a -> OpAlgebra a f
[getOpAlgebra] :: OpAlgebra a f -> AnAlgebra f a

-- | A co-algebra.
type ACoAlgebra f a = a -> f a
newtype CoAlgebra f a
CoAlgebra :: ACoAlgebra f a -> CoAlgebra f a
[getCoAlgebra] :: CoAlgebra f a -> ACoAlgebra f a

-- | a co-algebra (with the two types in reverse order).
newtype OpCoAlgebra a f
OpCoAlgebra :: ACoAlgebra f a -> OpCoAlgebra a f
[getOpCoAlgebra] :: OpCoAlgebra a f -> ACoAlgebra f a

-- | A natural transformation.
type (:~>) f g = forall x. f x -> g x

-- | A natural transformation.
type ANaturalTransformation f g = (:~>) f g
newtype NaturalTransformation f g
NaturalTransformation :: f :~> g -> NaturalTransformation f g
[getNaturalTransformation] :: NaturalTransformation f g -> f :~> g

-- | <pre>
--   ~ <a>NaturalTransformation</a> <tt>Identity</tt>
--   </pre>
newtype IdNaturalTransformation f
IdNaturalTransformation :: (forall x. ACoAlgebra f x) -> IdNaturalTransformation f
[getIdNaturalTransformation] :: IdNaturalTransformation f -> forall x. ACoAlgebra f x
newtype OpNaturalTransformation g f
OpNaturalTransformation :: f :~> g -> OpNaturalTransformation g f
[getOpNaturalTransformation] :: OpNaturalTransformation g f -> f :~> g

-- | <pre>
--   ~ <a>OpNaturalTransformation</a> <tt>Identity</tt>
--   </pre>
newtype IdOpNaturalTransformation f
IdOpNaturalTransformation :: (forall x. AnAlgebra f x) -> IdOpNaturalTransformation f
[getIdOpNaturalTransformation] :: IdOpNaturalTransformation f -> forall x. AnAlgebra f x

-- | a <tt>ConstraintKind</tt>.
--   
--   (<a>IsPairing</a> would be the constraints, if <a>Pairing</a> were a
--   class).
type IsPairing f g = (Functor f, Functor g)
data Pairing f g
Pairing :: (forall a b r. (a -> b -> r) -> (f a -> g b -> r)) -> Pairing f g
[pair] :: Pairing f g -> forall a b r. (a -> b -> r) -> (f a -> g b -> r)


module Vinyl.Effects.Language

-- | a domain-specific <tt>language</tt> that supports the
--   <tt>effects</tt>.
--   
--   e.g.
--   
--   <pre>
--   Language [f,g] a
--   </pre>
newtype Language effects a
Language :: FreeF (LanguageF effects) a (Language effects a) -> Language effects a
[getLanguage] :: Language effects a -> FreeF (LanguageF effects) a (Language effects a)

-- | <a>fmap</a>

-- | <a>pure</a> calls <a>Pure</a>

-- | <a>&gt;&gt;=</a> may call <a>Free</a>

-- | a (type-level) <tt>sum</tt> of "language features". Generally, a (1)
--   lifted, (2) n-ary, (3) associative sum.
--   
--   the <tt>expression</tt> may use any effect in <tt>effects</tt>:
--   
--   <pre>
--   expression :: LanguageF effects
--   </pre>
--   
--   generalizes <a>Either</a>:
--   
--   <pre>
--   LanguageF '[f,g] a
--   ~
--   Either (f a) (g a)
--   </pre>
newtype LanguageF (effects :: [* -> *]) (a :: *)
LanguageF :: (CoRec (Apply a) effects) -> LanguageF
[getLanguageF] :: LanguageF -> (CoRec (Apply a) effects)

-- | "inject" an <tt>effect</tt> into a set of <tt>effects</tt>.
--   
--   generalizes <a>Left</a> and <a>Right</a>:
--   
--   <ul>
--   <li><pre>Left ~ (liftE :: f a -&gt; LanguageF '[f,g] a)</pre></li>
--   <li><pre>Right ~ (liftE :: g a -&gt; LanguageF '[f,g] a)</pre></li>
--   </ul>
liftE :: (effect ∈ effects, Functor effect) => effect a -> LanguageF effects a

-- | the <tt>m</tt>onad supports each <tt>effect</tt>
--   
--   a "final encoding" (TODO, is it?) for injecting functors into a sum.
--   
--   Analogous to <a>liftF</a>.
--   
--   e.g.
--   
--   <pre>
--   data ClipboardF k = GetClipboard (String -&gt; k) | SetClipboard String k
--   
--   getClipboard :: (MonadClipboard m effects) =&gt; m String
--   getClipboard = liftL $ GetClipboard id
--      -- GetClipboard id :: ClipboardF String
--   
--   setClipboard :: (MonadClipboard m effects) =&gt; String -&gt; m ())
--   setClipboard s = liftL $ SetClipboard s ()
--     -- SetClipboard s () :: ClipboardF ()
--   
--   type MonadClipboard m effects = (MonadLanguage m effects, ClipboardF ∈ effects)
--   </pre>
--   
--   the <tt>FunctionalDependency</tt> (i.e. <tt>m -&gt; effects</tt>)
--   says: "a language-monad supports one set of effects".
class (Monad m) => MonadLanguage m effects | m -> effects
liftL :: (MonadLanguage m effects, f ∈ effects, Functor f) => f a -> m a

-- | The simplest concrete implementation for the interface.
--   
--   Analogous to <tt>(m ~ State s)</tt> for <tt>(MonadState m s)</tt>.
--   
--   <pre>
--   liftL = <a>liftE</a> &gt;&gt;&gt; <a>liftF</a>
--   </pre>
fromUnitLanguageF :: LanguageF '[f] a -> f a

-- | cast a (<tt>newtype</tt>'d) <tt>Language</tt> to <tt>Free</tt>. TODO
--   is cheap (can use <tt>coerce</tt>)?
fromLanguage :: Language effects a -> Free (LanguageF effects) a

-- | wraps <a>iter</a>.
iterL :: (LanguageF effects a -> a) -> (Language effects a -> a)

-- | wraps <a>iterM</a>.
iterLM :: (Monad m) => (LanguageF effects (m a) -> m a) -> (Language effects a -> m a)
instance GHC.Base.Functor (Vinyl.Effects.Language.Language effects)
instance GHC.Base.Applicative (Vinyl.Effects.Language.Language effects)
instance GHC.Base.Monad (Vinyl.Effects.Language.Language effects)
instance GHC.Base.Functor (Vinyl.Effects.Language.LanguageF effects)
instance Vinyl.Effects.Language.MonadLanguage (Vinyl.Effects.Language.Language effects) effects
instance Control.Monad.Free.Class.MonadFree (Vinyl.Effects.Language.LanguageF effects) (Vinyl.Effects.Language.Language effects)


-- | Making interpreters:
--   
--   <ul>
--   <li><a>singletonInterpreter</a>, from a handler</li>
--   </ul>
--   
--   Growing interpreters:
--   
--   <ul>
--   <li><a>appendInterpreters</a></li>
--   </ul>
--   
--   Shrinking an interpreter:
--   
--   <ul>
--   <li><a>downcastInterpreter</a>, when it handles more than you
--   need</li>
--   </ul>
--   
--   If you want to do more with them, just unwrap the <tt>newtype</tt> and
--   use <a>Data.Vinyl</a>.
module Vinyl.Effects.Interpreter.Simple

-- | a product of handlers.
--   
--   each field holds a co-algebra:
--   
--   <pre>
--   f (m a) -&gt; m a
--   </pre>
--   
--   e.g.
--   
--   <pre>
--   runFG :: Interpreter IO '[f,g]
--   runFG = Interpreter $ <a>HandlerM</a> runF :&amp; <a>HandlerM</a> runG :&amp; RNil
--   
--   runF :: f (m a) -&gt; m a
--   
--   runG :: g (m a) -&gt; m a
--   </pre>
--   
--   specialization:
--   
--   <pre>
--   Interpreter IO [f,g]
--   ~
--   Rec (<a>HandlerM</a> IO) [f,g]
--   ~
--   (HandlerM IO f, HandlerM IO g)
--   ~
--   ( (forall x. f (IO x) -&gt; IO x)
--   , (forall y. g (IO y) -&gt; IO y)
--   )
--   </pre>
newtype Interpreter (m :: * -> *) (effects :: [* -> *])
Interpreter :: Rec (HandlerM m) effects -> Interpreter
[getInterpreter] :: Interpreter -> Rec (HandlerM m) effects

-- | monadically handle a functor.
newtype HandlerM m f
HandlerM :: (forall x. f (m x) -> m x) -> HandlerM m f
[getHandlerM] :: HandlerM m f -> forall x. f (m x) -> m x

-- | A (1) lifted, (2) n-ary, (3) associative product.
--   
--   In particular, a <tt>product</tt> of "handlers".
--   
--   <tt>fs</tt> must all be <tt>Functor</tt>s.
--   
--   e.g.
--   
--   <pre>
--   ProductF [f,g] a
--   </pre>
--   
--   generalizes '(,)':
--   
--   <pre>
--   ProductF '[f,g] a
--   ~
--   (f a, g a)
--   </pre>
data ProductF fs a
ProductF :: Rec (Apply a) fs -> ProductF fs a
[getProductF] :: ProductF fs a -> Rec (Apply a) fs

-- | interpret a language into some monad.
--   
--   e.g.
--   
--   <pre>
--   interpretLanguage anInterpreter aLanguage :: m ()
--   </pre>
--   
--   calls <a>iterLM</a>.
interpretLanguage :: (Monad m) => Interpreter m effects -> (Language effects :~> m)

-- | you consume a coproduct with a product of consumers i.e. you must
--   handle every case.
--   
--   like <a>match</a>.
interpretLanguageF :: Interpreter m effects -> AnAlgebra (LanguageF effects) (m a)

-- | make a interpreter from a single handler.
--   
--   e.g.
--   
--   <pre>
--   data ClipboardF k = GetClipboard (String -&gt; k) | SetClipboard String k deriving Functor
--   
--   clipboardInterpreter :: Interpreter IO '[ClipboardF] a
--   clipboardInterpreter = singletonInterpreter $ \case
--    GetClipboard f   -&gt; ... &gt;&gt;= f
--    SetClipboard s k -&gt; ... s &gt;&gt; k
--   </pre>
singletonInterpreter :: (forall x. AnAlgebra f (m x)) -> Interpreter m '[f]

-- | compose two interpreters. ordered.
appendInterpreters :: Interpreter m fs -> Interpreter m gs -> Interpreter m (fs ++ gs)

-- | Discard any number of handlers from the interpreter.
downcastInterpreter :: (gs ⊆ fs) => Interpreter m fs -> Interpreter m gs

-- | Lift a (unary) function on records to interpreters (a newtype
--   thereof).
--   
--   e.g.
--   
--   <pre>
--   <a>downcastInterpreter</a> = asInterpreter1 <a>rcast</a>
--   </pre>
asInterpreter1 :: (Rec (HandlerM m) fs -> Rec (HandlerM m) gs) -> (Interpreter m fs -> Interpreter m gs)

-- | Lift an operation on records to interpreters (a newtype thereof).
--   
--   e.g.
--   
--   <pre>
--   <a>appendInterpreters</a> = asInterpreter2 (<a>&lt;+&gt;</a>)
--   </pre>
asInterpreter2 :: (Rec (HandlerM m) fs -> Rec (HandlerM m) gs -> Rec (HandlerM m) hs) -> (Interpreter m fs -> Interpreter m gs -> Interpreter m hs)

-- | inverts <a>singletonInterpreter</a>, for convenient access.
fromSingletonInterpreter :: Interpreter m '[f] -> AnAlgebra f (m a)

module Vinyl.Effects.Interpreter


-- | Extensible effects. Minimal boilerplate. (Weakened inference).
--   
--   See <a>Vinyl.Effects.Example</a> for a detailed tutorial.
--   
--   Dependencies:
--   
--   <ul>
--   <li>the <tt>free</tt> package, for <tt>Free</tt> (which transforms a
--   functor into a monad) and <tt>Cofree</tt> (which transforms a functor
--   into a comonad).</li>
--   <li>the <tt>vinyl</tt> package, for (TODO) <a>CoRec</a> (an n-ary,
--   un-nested sum type) and <a>Rec</a> (an n-ary, un-nested product
--   type).</li>
--   </ul>
--   
--   Concepts (necessary only for contributing to the library, not using
--   it):
--   
--   <ul>
--   <li>for composing domain-specific languages and interpeters (parts 1
--   to
--   5):<ul><li><a>http://dlaing.org/cofun/posts/free_and_cofree.html</a></li><li><a>http://dlaing.org/cofun/posts/monad_transformers_and_comonad_transformers.html</a></li><li><a>http://dlaing.org/cofun/posts/coproducts_for_free_and_products_for_cofree.html</a></li><li><a>http://dlaing.org/cofun/posts/pairing_and_io.html</a></li><li><a>http://dlaing.org/cofun/posts/pairing_over_the_network.html</a></li><li>(this
--   series a tour-de-force, read it!).</li></ul></li>
--   <li>for "extensible
--   records":<ul><li><a>https://hackage.haskell.org/package/vinyl-0.5.2/docs/Data-Vinyl-Tutorial-Overview.html</a></li></ul></li>
--   <li>for "free monads":<ul><li>&lt;&gt; TODO tekmos blog</li></ul></li>
--   <li>for "extensible effects":<ul><li>&lt;&gt; TODO
--   ocharles</li></ul></li>
--   <li>for <tt>mtl</tt>:<ul><li>&lt;&gt; TODO</li></ul></li>
--   </ul>
--   
--   Reverse Dependencies:
--   
--   <ul>
--   <li>packdeps.haskellers.com<i>reverse</i>vinyl-effects</li>
--   <li>TODO <a>workflow-types</a> uses this package to maximize the
--   effects the platform-independent monad provides, while still
--   preserving the richer effects the platform-specific monads provide (in
--   <a>workflow-linux</a>, <a>workflow-osx</a>, and
--   <a>workflow-windows</a>). e.g. <tt>OSX</tt> can easily access the
--   clipboard via <tt>bash</tt>.</li>
--   </ul>
--   
--   Extensions:
--   
--   <ul>
--   <li>The effects as a type-level set, not a type-level list (from
--   <a>GHC.TypeLits</a>); i.e. the items are unique. (Currently, I think
--   the duplicates are ignored).</li>
--   <li>"extensible interpreters" via cofree comonads. (The original
--   motivation for this package only needed the <a>Language</a> to be
--   extensible).</li>
--   </ul>
--   
--   Existing Alternatives:
--   
--   <ul>
--   <li><a>effects</a>: uses <tt>-XOverloadedInstances</tt>. bad
--   inference?</li>
--   <li>&lt;&gt; romansch:</li>
--   <li>&lt;&gt; ocharles:</li>
--   <li>&lt;&gt; mtl: doesn't compose</li>
--   </ul>
module Vinyl.Effects


-- | This module defines two effects (<a>Clipboard</a> and <a>OpenUrl</a>),
--   and then composes them (<a>Workflow</a>) "on-the-fly".
--   
--   For each effect, we:
--   
--   <ul>
--   <li>Define a functor (e.g. <a>ClipboardF</a>).</li>
--   <li>(optionally, for convenience, define aliases for the constraint
--   (e.g. <a>MonadClipboard</a>) and effect-set (e.g.
--   <a>Clipboard</a>)).</li>
--   <li>Define overloaded constructors (e.g. <a>getClipboard</a>,
--   <a>setClipboard</a>). TODO th.</li>
--   <li>Define a handler (e.g. <tt>(<a>handleClipboard</a> ::
--   <a>ClipboardF</a> (<a>IO</a> a) -&gt; <a>IO</a> a)</tt>), which
--   involves minimal boilerplate. (if you've used the <tt>free</tt>
--   package, you know how it's done). Then, wrap that handler (e.g. with
--   the shape <tt><a>ClipboardF</a> a -&gt; a</tt>) in an
--   <a>Interpreter</a>, for <i>extensibility</i>.</li>
--   </ul>
--   
--   You can use these effects extensibly, "<tt>mtl</tt>-style". e.g. Since
--   <a>getClipboard</a> and <a>openUrl</a> are overloaded, they can both
--   be used in <a>openFromClipboard</a>.
--   
--   <pre>
--   <a>openFromClipboard</a> = do   -- :: (<a>MonadClipboard</a> m, <a>MonadOpenUrl</a> m) =&gt; m ()
--     s &lt;- <a>getClipboard</a>      -- :: (<a>MonadClipboard</a> m                ) =&gt; m String
--     <a>openUrl</a> s              -- :: (                  <a>MonadOpenUrl</a> m) =&gt; m ()
--   </pre>
--   
--   Note:
--   
--   <ul>
--   <li>the type of <tt>openFromClipboard</tt> is inferred.</li>
--   <li>the constraints are aliases; you don't need to write a new class
--   for each new effect type.</li>
--   <li>for compositions of effects (like <a>MonadWorkflow</a>), you don't
--   even need to write a new type. Just append the interpreters you want
--   (with <a>appendInterpreters</a>).</li>
--   </ul>
module Vinyl.Effects.Example

-- | run with:
--   
--   <pre>
--   stack build &amp;&amp; stack exec example-vinyl-effects
--   </pre>
--   
--   (read the source too).
main :: IO ()

-- | the constraint
type MonadClipboard m effects = (MonadLanguage m effects, ClipboardF ∈ effects)

-- | the set of effects (one)
type Clipboard = '[ClipboardF]

-- | the functor
data ClipboardF k
GetClipboard :: (String -> k) -> ClipboardF k
SetClipboard :: String -> k -> ClipboardF k

-- | <pre>
--   getClipboard = <a>liftL</a> $ <a>GetClipboard</a> id
--   </pre>
getClipboard :: (MonadClipboard m effects) => m String

-- | <pre>
--   setClipboard s = <a>liftL</a> $ <a>SetClipboard</a> s ()
--   </pre>
setClipboard :: (MonadClipboard m effects) => String -> m ()

-- | derived from the two primitves.
reverseClipboard :: (MonadClipboard m effects) => m ()

-- | calls <a>interpretLanguage</a>.
--   
--   when using free monads directly, you would:
--   
--   <pre>
--   runClipboard = <tt>iterTM</tt> handleClipboard
--   </pre>
runClipboard :: Language '[ClipboardF] :~> IO

-- | definition #1: "inject" a handler into an interpreter with
--   <a>singletonInterpreter</a>.
--   
--   <pre>
--   <a>singletonInterpreter</a> <a>handleClipboard</a>
--   </pre>
interpretClipboard :: Interpreter IO '[ClipboardF]

-- | definition #2: constructed and interpreted directly from single
--   handler.
--   
--   <pre>
--   = <a>Interpreter</a>
--     $ <a>HandlerM</a> <a>handleClipboard</a>
--     <a>:&amp;</a> <a>RNil</a>
--   </pre>
interpretClipboard2 :: Interpreter IO '[ClipboardF]

-- | glue the functor to its effects.
--   
--   <pre>
--   handleClipboard = \case
--     <a>GetClipboard</a> f   -&gt; <a>sh_GetClipboard</a> <a>&gt;&gt;=</a> f
--     <a>SetClipboard</a> s k -&gt; <a>sh_SetClipboard</a> s <a>&gt;&gt;</a> k
--   </pre>
handleClipboard :: AnAlgebra ClipboardF (IO a)

-- | shells out (<tt>$ pbpaste</tt>), works only on OSX.
sh_GetClipboard :: IO String

-- | shells out (<tt>$ ... | pbcopy</tt>), works only on OSX. blocking.
sh_SetClipboard :: String -> IO ()

-- | the constraint
type MonadOpenUrl m effects = (MonadLanguage m effects, OpenUrlF ∈ effects)

-- | the set of effects (one)
type OpenUrl = '[OpenUrlF]

-- | the functor
data OpenUrlF k

-- | <pre>
--   openUrl s = <a>liftL</a> $ <a>OpenUrl</a> s ()
--   </pre>
openUrl :: (MonadOpenUrl m effects) => String -> m ()

-- | <pre>
--   runOpenUrl = interpretLanguage interpretOpenUrl
--   </pre>
runOpenUrl :: Language '[OpenUrlF] :~> IO

-- | <pre>
--   interpretOpenUrl = <a>singletonInterpreter</a> $ case
--     <a>OpenUrl</a> s k -&gt; <a>sh_OpenUrl</a> s &gt;&gt; k
--   </pre>
--   
--   can extract the "co-algebra" with
--   
--   <pre>
--   handleOpenUrl = <a>fromSingletonInterpreter</a> interpretOpenUrl
--   </pre>
interpretOpenUrl :: Interpreter IO '[OpenUrlF]

-- | glue the functor to its effects.
--   
--   <pre>
--   handleOpenUrl = \case
--     <a>OpenUrl</a> s k -&gt; <a>sh_OpenUrl</a> s <a>&gt;&gt;</a> k
--   </pre>
handleOpenUrl :: AnAlgebra OpenUrlF (IO a)

-- | shells out (<tt>$ open ...</tt>), should work cross-platform.
--   blocking.
sh_OpenUrl :: String -> IO ()

-- | a constraint (with <tt>-XConstraintKinds</tt>).
type MonadWorkflow m effects = (MonadClipboard m effects, MonadOpenUrl m effects)

-- | a set of two effects.
type Workflow = '[ClipboardF, OpenUrlF]

-- | run an ad-hoc grouping of two effects.
--   
--   <pre>
--   runWorkflow = <a>interpretLanguage</a> interpretWorkflow1
--   </pre>
--   
--   can run any action of type:
--   
--   <pre>
--   (<a>MonadWorkflow</a> m effects) =&gt; m a
--   </pre>
runWorkflow :: Language Workflow :~> IO

-- | definition #1: compose interpreters by appending vinyl records.
--   
--   <pre>
--   interpretWorkflow = <a>appendInterpreters</a> <a>interpretClipboard</a> <a>interpretOpenUrl</a>
--   </pre>
--   
--   no new <tt>Either</tt>-like <tt>data</tt>types needed, the
--   <tt>type</tt>-aliases are only for clarity.
interpretWorkflow1 :: Interpreter IO Workflow

-- | definition #2: Construct an interpreter directly, via handlers.
--   
--   <pre>
--   <a>Interpreter</a>
--     $ <a>HandlerM</a> <a>handleClipboard</a>
--    :&amp; <a>HandlerM</a> <a>handleOpenUrl</a>
--    :&amp; RNil
--   </pre>
interpretWorkflow2 :: Interpreter IO Workflow

-- | If we can handle an effect, plus some others; then we can handle that
--   effect, alone.
--   
--   <pre>
--   <a>interpretOpenUrl2</a> = <a>downcastInterpreter</a> <a>interpretWorkflow1</a>
--   </pre>
--   
--   This casts <tt>'[<a>ClipboardF</a>,<a>OpenUrlF</a>]</tt> down to
--   <tt>'[<a>OpenUrlF</a>]</tt>.
--   
--   (For example, some library exports only a single interpreter that
--   handles five effects. We can reconstruct an interpreter that handles
--   only three of those effects with a one-liner).
interpretOpenUrl2 :: Interpreter IO OpenUrl

-- | an effect to visit the url that's currently in the clipboard.
--   
--   uses two distinct effects, i.e. it's a <a>Workflow</a> action.
--   
--   <pre>
--   openFromClipboard = do
--     s &lt;- <a>getClipboard</a>
--     <a>openUrl</a> s
--   </pre>
--   
--   Inferred (with <tt>NoMonomorphismRestriction</tt>):
--   
--   <pre>
--   :: ( <a>MonadClipboard</a> m effects
--      , <a>MonadOpenUrl</a> m effects
--      )
--   =&gt; m ()
--   </pre>
--   
--   (the same, without aliases)
--   
--   <pre>
--   :: ( <a>MonadLanguage</a> m effects
--      , <a>RElem</a> ClipboardF effects (<tt>RIndex</tt> ClipboardF effects)
--      , <a>RElem</a> OpenUrlF   effects (<tt>RIndex</tt> OpenUrlF   effects)
--      )
--   =&gt; m ()
--   </pre>
--   
--   (which is what haddock displays, unformatted).
--   
--   i.e. "any monad, that supports any set of effects that have at least
--   <a>ClipboardF</a> and <a>OpenUrlF</a>".
--   
--   you can specialize the effects:
--   
--   <pre>
--   openFromClipboard
--    :: (<a>MonadLanguage</a> m [ClipboardF, OpenUrlF])
--    =&gt; m ()
--   </pre>
--   
--   i.e. "any monad, that supports exactly two effects, <a>ClipboardF</a>
--   and <a>OpenUrlF</a>".
--   
--   or the monad:
--   
--   <pre>
--   openFromClipboard
--     :: (ClipboardF ∈ effects, OpenUrlF ∈ effects)
--     =&gt; <a>Language</a> effects ()
--   </pre>
--   
--   or both:
--   
--   <pre>
--   openFromClipboard
--    () =&gt;
--    :: <a>Language</a> [ClipboardF, OpenUrlF] ()
--   </pre>
openFromClipboard :: (RElem (* -> *) OpenUrlF effects (RIndex (* -> *) OpenUrlF effects), RElem (* -> *) ClipboardF effects (RIndex (* -> *) ClipboardF effects), MonadLanguage m effects) => m ()

-- | <pre>
--   = <a>openFromClipboard</a>
--   </pre>
openFromClipboard_nothingSpecialized :: (MonadWorkflow m effects) => m ()

-- | <pre>
--   = <a>openFromClipboard</a>
--   </pre>
openFromClipboard_monadSpecialized :: (ClipboardF ∈ effects, OpenUrlF ∈ effects) => Language effects ()

-- | <pre>
--   = <a>openFromClipboard</a>
--   </pre>
openFromClipboard_effectsSpecialized :: (MonadLanguage m '[ClipboardF, OpenUrlF]) => m ()

-- | <pre>
--   = <a>openFromClipboard</a>
--   </pre>
openFromClipboard_bothSpecialized :: Language '[ClipboardF, OpenUrlF] ()

-- | the constraint
type MonadReader r m effects = (MonadLanguage m effects, ReaderF r ∈ effects)

-- | the set of effects (one)
type Reader r = '[ReaderF r]

-- | the functor
data ReaderF r k

-- | <pre>
--   ask = <a>liftL</a> $ <a>Ask</a> id
--   </pre>
ask :: (MonadReader r m effects) => m r

-- | the constraint
type MonadWriter w m effects = (MonadLanguage m effects, WriterF w ∈ effects)

-- | the set of effects (one)
type Writer w = '[WriterF w]

-- | the functor
data WriterF w k

-- | <pre>
--   tell w = <a>liftL</a> $ <a>Tell</a> w ()
--   </pre>
tell :: (MonadWriter w m effects) => w -> m ()

-- | the constraint
type MonadState s m effects = (MonadLanguage m effects, StateF s ∈ effects)

-- | the set of effects (one)
type State s = '[StateF s]

-- | the functor
data StateF s k

-- | <pre>
--   get = <a>liftL</a> $ <a>Get</a> id
--   </pre>
get :: (MonadState s m effects) => m s

-- | <pre>
--   put s = <a>liftL</a> $ <a>Put</a> s ()
--   </pre>
put :: (MonadState s m effects) => s -> m ()

-- | since 'MonadLanguage is a class, even though <a>RWS</a> is a custom
--   monad (not a <a>Language</a>), you can still provide an instance.
--   
--   The instance declares that <tt>RWS</tt> has three effects: reading an
--   environment, logging, and state access. Which means that the functors
--   (<a>ReaderF</a>, <a>WriterF</a>, <a>StateF</a>) can be injected into
--   our concrete/custom monad stack.
--   
--   Thus <a>exampleRWS</a>, which is built with overloaded procedures
--   (<a>ask</a>,<a>tell</a>,<a>get</a>,<a>put</a> are from this module,
--   not the <tt>mtl</tt> package), can be specialized to both a
--   <a>Language</a>:
--   
--   <pre>
--   -- <a>exampleRWS_specializedLanguage</a>
--   exampleRWS
--    :: (Num i, Show i)
--    =&gt; Language [ReaderF Bool, WriterF [String], StateF i] i
--   </pre>
--   
--   and the more familiar <a>RWS</a>:
--   
--   <pre>
--   -- <a>exampleRWS_specializedRWS</a>
--   exampleRWS
--    :: (Num i, Show i)
--    =&gt; RWS Bool [String] i i
--   </pre>
--   
--   To "lift the effect", we define a record of liftings for **each**
--   possible effect:
--   
--   <pre>
--   <a>liftRWS</a>
--      = OpNaturalTransformation <a>liftReaderF</a>
--     :&amp; OpNaturalTransformation <a>liftWriterF</a>
--     :&amp; OpNaturalTransformation <a>liftStateF</a>
--     :&amp; RNil
--   
--     -- (the <a>OpNaturalTransformation</a> is boilerplate)
--   </pre>
--   
--   and then perform a record lookup for **the** particular effect given
--   at runtime:
--   
--   <pre>
--   instance (<a>Monoid</a> w) =&gt; <a>MonadLanguage</a> (RWS r w s) [<a>ReaderF</a> r, <a>WriterF</a> w, <a>StateF</a> s] where
--     <a>liftL</a> effect = <a>getOpNaturalTransformation</a> (<a>rget</a> <a>Proxy</a> <a>liftRWS</a>) effect
--   </pre>
--   
--   For example, when the <tt>effect</tt> is <tt><a>ask</a></tt>:
--   
--   <pre>
--   liftL ask
--   =
--   liftL ask
--   =
--   getOpNaturalTransformation (rget Proxy liftRWS) ask
--   =
--   getOpNaturalTransformation (OpNaturalTransformation liftReaderF) ask
--   =
--   liftReaderF ask
--   =
--   liftReaderF (Ask id)
--   =
--   RWS $ ReaderT $ r -&gt; do
--     return (id r)
--   =
--   RWS $ ReaderT $ r -&gt; do
--     return r
--   =
--   RWS $ ReaderT return
--   </pre>
newtype RWS r w s a
RWS :: ReaderT r (WriterT w (StateT s Identity)) a -> RWS r w s a
[getRWS] :: RWS r w s a -> ReaderT r (WriterT w (StateT s Identity)) a
runRWS :: (Monoid w) => r -> s -> RWS r w s a -> (a, w, s)
liftRWS :: (Monoid w) => Rec (OpNaturalTransformation (RWS r w s)) '[ReaderF r, WriterF w, StateF s]
liftReaderF :: (Monoid w) => ReaderF r a -> RWS r w s a
liftWriterF :: (Monoid w) => WriterF w a -> RWS r w s a
liftStateF :: (Monoid w) => StateF s a -> RWS r w s a

-- | uses all four effectful operations
--   (<a>ask</a>,<a>tell</a>,<a>get</a>,<a>put</a>).
exampleRWS :: (MonadReader Bool m effects, MonadWriter [String] m effects, MonadState i m effects, Num i, Show i) => m i

-- | <pre>
--   = <a>exampleRWS</a>
--   </pre>
exampleRWS_specializedLanguage :: (Num i, Show i) => Language '[ReaderF Bool, WriterF [String], StateF i] i

-- | <pre>
--   = <a>exampleRWS</a>
--   </pre>
exampleRWS_specializedRWS :: (Num i, Show i) => RWS Bool [String] i i
instance GHC.Base.Monoid w => GHC.Base.Monad (Vinyl.Effects.Example.RWS r w s)
instance GHC.Base.Monoid w => GHC.Base.Applicative (Vinyl.Effects.Example.RWS r w s)
instance GHC.Base.Functor (Vinyl.Effects.Example.RWS r w s)
instance GHC.Base.Functor (Vinyl.Effects.Example.StateF s)
instance GHC.Base.Functor (Vinyl.Effects.Example.WriterF w)
instance GHC.Base.Functor (Vinyl.Effects.Example.ReaderF r)
instance GHC.Base.Functor Vinyl.Effects.Example.OpenUrlF
instance GHC.Base.Functor Vinyl.Effects.Example.ClipboardF
instance GHC.Base.Monoid w => Vinyl.Effects.Language.MonadLanguage (Vinyl.Effects.Example.RWS r w s) '[Vinyl.Effects.Example.ReaderF r, Vinyl.Effects.Example.WriterF w, Vinyl.Effects.Example.StateF s]
